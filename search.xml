<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hexo+Github+Netlify搭建个人博客</title>
      <link href="/2019/04/20/hexo+github+netlify%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<h3 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h3><p>  我的博客在曾经的很长一段时间以内,我都是将博客静态页面托管到<a href="https://pages.github.com/" target="_blank" rel="noopener">Github pages</a>进行渲染的,但是大家都知道,我们国内访问GitHub如果不挂<del>翻墙</del>的话,访问速度非常慢☹️.虽然我的博客一直以来都没有太多的访问量,但是作为一个追求极致体验的人,怎么忍受得了呢 🤟.<a id="more"></a></p><h3 id="寻找方案"><a href="#寻找方案" class="headerlink" title="寻找方案"></a>寻找方案</h3><p>  于是我在网上搜索最优化的解决方案.我想的是,生成博客的渲染框架还是使用<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>,但是页面托管我得重新找一个托管商,于是我在vue的官网,知道了<a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlify</a>这个神器.Netlify是什么：</p><blockquote><p>Netlify is a unified platform that automates your code to create high-performant, easily maintainable sites and web apps.</p></blockquote><p>我看了官网的介绍,总结一下,它有如下功能：</p><ul><li>可以托管静态资源</li><li>可以将静态网站部署到CDN上</li><li>Continuous Deployment 持续部署,当你提交改变到git 仓库,它就会自动运行build command,进行自动部署</li><li>可以添加自定义域名</li><li>重头戏：<strong>可以启用免费的TLS证书,启用HTTPS</strong></li></ul><p>Oh my God!!,这可比Git pages好太多了👏我们来对比一下Github pages：</p><ul><li><p>github虽然没有被墙,但是那个访问速度非常的慢,对国内访问的用户来说体验极差</p></li><li><p>百度无法抓取,众所周知国内用百度的还是多,如果你写的文章,无法被百度抓取收录,那还是有点坑的</p></li><li><p>配置繁琐,使用不友好.https证书配置这一项就麻烦的要死</p></li><li><p>无法做CDN加速.未备案域名服务器,无法使用国内的cnd加速服务</p></li></ul><p>所以,我准备采用Netlify作为我的页面托管商.下面我们即将开始搭建博客咯！</p><h3 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h3><p>​    第一步,我们需要安装<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></p><p>​    安装hexo之前需要安装一下环境：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>安装完node后由于npm是自带的,可能版本有些落后,需要先将自身升级一下.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm -g install npm</span><br></pre></td></tr></table></figure><p>不能翻墙的同学,可使用npm淘宝镜像cnpm:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><blockquote><p>注：安装了淘宝源的镜像cnpm之后,接下来所有的npm 开头的命令均使用<code>cnpm</code>来代替</p></blockquote><p>接着我们来安装Hexo：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>测试一下是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><p>然后在我们的电脑上,选择一个目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &quot;博客目录&quot; #使用hexo命令在指定的&lt;folder&gt;文件夹下初始化创建一个博客项目</span><br><span class="line">$ cd &lt;folder&gt;         #进入创建好的项目目录</span><br><span class="line">$ npm install         #使用npm安装所需依赖.</span><br></pre></td></tr></table></figure><p>这个新建的”博客目录”就是用来作为你以后存放博客的目录,这其中包括博客的配置、文章等等的一切.新建完成之后,我们用任何一个代码编辑器打开我们刚刚新建的目录,有如下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><blockquote><p>注：这里会涉及一些<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo cli</a>的指令,请自行学习一下,以后都会用到的.</p></blockquote><p>然后我们试着跑一下,看是否能够成功启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean #清理各种缓存和旧文件</span><br><span class="line">$ hexo g     #生成静态文件</span><br><span class="line">$ hexo s     #开启服务器预览</span><br></pre></td></tr></table></figure><p>执行完 <code>hexo s</code> 后命令行窗口将提示您如下信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>打开<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可预览你的第一篇hexo博文.</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>  接下来才是重头戏：进入部署环节.在正式进行部署之前,我先来讲一下什么是部署：</p><p> 当我们使用 <code>hexo g</code> 和 <code>hexo s</code> 命令生成并开启服务后,我们本地访问的测试域名-<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 实际是指向了我们当前目录下的 public 目录,也就是说 <code>hexo g</code> 命令会生成 public 目录,这个目录下面装着我们的静态页面文件和相关依赖,部署的过程就是将这个 public 目录下的文件放到我们的服务器上这样就完成了部署.</p><p>好了接下来我们来进行部署：</p><h4 id="同步到Github"><a href="#同步到Github" class="headerlink" title="同步到Github"></a>同步到Github</h4><p>先到GitHub新建一个repository:</p><p><img src="https://i.loli.net/2019/04/24/5cc0876b108de.png" alt="QQ20190424-235658@2x.png"></p><p>复制你刚刚新建的repository的地址,像这样: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/xieyezi/your-Repository.git</span><br></pre></td></tr></table></figure><p>  回到项目根目录,将你的本地项目和新建的repository联系起来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/xieyezi/your-Repository.git</span><br></pre></td></tr></table></figure><p>  在当前根目录下新建.gitignore文件<br>  将不需要同步的文件和目录写到.gitignore:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">themes/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><p>  完成之后,到根目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;commit information&apos;</span><br></pre></td></tr></table></figure><p>  接着推送到GitHub:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><p>到这里,我们已经讲我们的项目推送到GitHub的master分支下面了.接下来我们要对hexo进行一些配置:</p><p>打开hexo根目录的<code>_config.yml</code>文件找到deploy项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git #部署方式</span><br><span class="line">  repository: git@github.com:xieyezi/your-Repository.git #关联github仓库</span><br><span class="line">  branch: run-page #部署分支</span><br></pre></td></tr></table></figure><p>在这里,我们将在这个项目仓库下新建一个<code>run-page</code>分支,至于有什么用,我等一下会解释,先跟着我操作起来.</p><p>配置好了之后,保存退出,我们重新执行一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean #清理各种缓存和旧文件</span><br><span class="line">$ hexo g     #生成静态文件</span><br></pre></td></tr></table></figure><p>最后,我们将public目录同步到Github:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d #部署应用</span><br></pre></td></tr></table></figure><p>在执行这个命令的时候,我们可能会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ERROR Deployer not found: git</span><br></pre></td></tr></table></figure><p>那是因为我们缺少一个依赖,我们安装一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后再次执行一下,执行完成我们到Github 会发现我们的项目多了一个<code>run-page</code>,这个分支就是我们后面要用来生成我们到静态页面的.</p><h4 id="托管到Netlify"><a href="#托管到Netlify" class="headerlink" title="托管到Netlify"></a>托管到Netlify</h4><p>我们先到<a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlify</a>官网注册一下账号,因为我们是将项目托管到GitHub的,所以我们选择GitHub登录：</p><p><img src="https://i.loli.net/2019/04/25/5cc08d58a4e22.png" alt="QQ20190425-002152@2x.png"></p><p>进入官网,点击新建：</p><p><img src="https://i.loli.net/2019/04/25/5cc08f8a6b0d1.png" alt="QQ20190425-002343@2x.png"></p><p>选择GitHub来源：</p><p><img src="https://i.loli.net/2019/04/25/5cc08f8e877c0.png" alt="QQ20190425-002408@2x.png"></p><p>然后选择我们刚刚新建的项目：</p><p><img src="https://i.loli.net/2019/04/25/5cc08f8f64abc.png" alt="QQ20190425-002857@2x.png"></p><p>进入一步进行配置：</p><p><img src="/images/placeholder.png" alt="QQ20190425-003120@2x.png" data-src="https://i.loli.net/2019/04/25/5cc08f8f8c841.png" class="lazyload"></p><p>接着等待一会儿,Netlify会自动帮我们生成网址：</p><p><img src="/images/placeholder.png" alt="QQ20190425-003723@2x.png" data-src="https://i.loli.net/2019/04/25/5cc090e2f0713.png" class="lazyload"></p><p>第一次新建的时候,它会随机生成一个Netlify的二级域名,我们可以进行自定义二级域名,点击”Change site name”即可进行设置,像这样：</p><p><img src="/images/placeholder.png" alt="QQ20190425-004139@2x.png" data-src="https://i.loli.net/2019/04/25/5cc091d29a563.png" class="lazyload"></p><p>点击Save,等待Netlify进行热部署即可.</p><p>然后点击创建好的二级域名,成功访问✌️！！！</p><p>以后我们写好博客之后,直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean </span><br><span class="line">$ hexo g     </span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>我们的个人博客就会自动进行刷新,是不是超厉害！！</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p> 部署完成之后,到这里,可能有的同学会觉得很晕,我画了一个部署的流程图：</p><p><img src="/images/placeholder.png" alt="QQ20190425-144946@2x.png" data-src="https://i.loli.net/2019/04/25/5cc1589723558.png" class="lazyload"></p><p>这就是我们为什么要利用两个分支的原因,我们将我们的项目分支托管到<code>master</code>,然后将生成的<code>public</code>目录,托管到<code>run-page</code>分支,以后我们可以写完博客以后,就可以直接输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean </span><br><span class="line">$ hexo g     </span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>进行我们博客的推送,一旦我们推送到<code>run-page</code>分支,Netlify监测到我们的仓库发生了变化,就会根据这个分支的变化进行实时拉取并部署.</p><p>怎么样,你有没有学会呢？</p>]]></content>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Netlify </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue多个组件映射到同一个组件,页面不刷新？</title>
      <link href="/2019/04/20/Vue%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%98%A0%E5%B0%84%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6,%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0%EF%BC%9F/"/>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在做项目的过程中,有这么一个场景：多个组件通过配置路由,都跳转到同一个组件,他们之间的区别就是,传入的参数不同.请看<code>router</code>对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">userCenterLike: &#123;</span><br><span class="line">                    name: <span class="string">'user-center'</span>,</span><br><span class="line">                    params: &#123;</span><br><span class="line">                        index: <span class="number">0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">userCenterHistory: &#123;</span><br><span class="line">                    name: <span class="string">'user-center'</span>,</span><br><span class="line">                    params: &#123;</span><br><span class="line">                        index: <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>仅仅只是传入的index的值不同.但是在查看效果的过程中我发现：目标组件’user-center’始终只渲染一次,也就是说,第二次访问到同一路由的时候,Vue那些生命周期的钩子已经没有用了,根本无法通过<code>this.$route.params.index</code>来获取参数.</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>Vue的官网已经给出了详细解释：</p><blockquote><blockquote><p>提醒一下,当使用路由参数时,例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>,原来的组件实例会被复用.因为两个路由都渲染同个组件,比起销毁再创建,复用则显得更加高效.不过,这也意味着组件的生命周期钩子不会再被调用</p></blockquote></blockquote><p>也就是说,一开始Vue就是这样设计的,为了节省每次都要重建页面的内存开销,所以就复用.那么如何解决呢？</p><p>在这里,我们可以通过监听路由的变化来获取参数并进行操作,在<code>watch</code>钩子里面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'$route'</span>(to,<span class="keyword">from</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.$route.params.index !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.params.index);</span><br><span class="line">                &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样就可以在路由变化的同时,将我们的参数传入,实现页面的数据刷新.</p>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次自己封装NPM包的经历</title>
      <link href="/2019/03/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84NPM%E5%8C%85%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
      <content type="html"><![CDATA[<h3 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h3><p>最近一直在忙自己的毕业设计,在做的过程中,有的地方要用到缓存.我采用了localStorage和sessionStorage的方式进行的缓存,并完整地实现了自己想要的功能.但是我突然想到前端的”模块化开发”,这块完全可以独立出来,将其封装为一个统一的API,想要使用的时候就引入使用,于是我将其封装为了一个将localStorage和sessionStorage统一在一起的功能函数:<code>xieyezi-storage.js</code>.我存放在自己的电脑里面,以便我自己以后使用,但是我突然想到了程序员的”开源精神”😹,好吧其实是想到,每次我们需要安装一个包的时候,我们都是采用<code>npm install xxx</code>的方式进行引入,然后在使用的时候,就通过<code>import xxx from xxx</code> 这样的方式进行使用.于是我也想要将我的功能函数封装为一个npm包,并且发布到<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>👆上面去,那也算是为我们开源作出了一定的贡献.<a id="more"></a></p><h3 id="说得简单-动手困难"><a href="#说得简单-动手困难" class="headerlink" title="说得简单,动手困难"></a>说得简单,动手困难</h3><p>世界上很多事情都是说起来容易,做起来比较难,并且,万事开头难.我发现我自己缺乏这方面的很多知识,于是我开始了边学边写的模式.<br>在前期的考察中,我看了许多的npm包的源码,他们都有差不多类似的目录结构,于是我依葫芦画瓢,构建了如下的目录结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line"> ├── ./dist</span><br><span class="line"> └── ./src</span><br><span class="line">     └── ./src/index.js</span><br></pre></td></tr></table></figure><p>我执行了一下npm 的初始化工程命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>目录变成了这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── ./dist</span><br><span class="line">├── ./package.json</span><br><span class="line">└── ./src</span><br><span class="line">    └── ./src/index.js</span><br></pre></td></tr></table></figure><p>原来初始化包都会有一个package.json,这个文件包含了这个包的入口及其信息<br>在src目录下面存放功能代码<code>index.js</code>,dist目录下面则存放打包后的文件<code>xieyezi-storage.js</code><br>一切都已经准备就绪,我开始寻找一个打包工具.</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>在众多的打包工具中,我第一个想到的打包工具就是webpack,于是先安装(在根目录):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>然后靠着自己对webpack的浅薄知识,含泪写下了配置文件(webpack.config.js):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'xieyezi-storage.js'</span>,</span><br><span class="line">    publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>于是打包之后,生成了<code>xieyezi-storage.js</code>的文件,于是我将此文件复制到我的项目目录里面进行引入使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span> <span class="string">'common/js/xieyezi-storage'</span></span><br></pre></td></tr></table></figure></p><p>结果是我成功地引入了文件并进行了使用.但是我这是ES6规范,并不能支持commonJS模式,说到这个,有如下标准:</p><ul><li>amd – 异步模块定义,用于像RequireJS这样的模块加载器</li><li>cjs – CommonJS,适用于 Node 和 Browserify/Webpack 例如<code>require(&#39;xieyezi-storage&#39;)</code></li><li>es – 将软件包保存为ES模块文件 例如 <code>import storage from &#39;xieyezi-storage&#39;</code>.</li><li>iife – 一个自动执行的功能,适合作为<code>&lt;script&gt;</code>标签.（如果要为应用程序创建一个捆绑包,您可能想要使用它,因为它会使文件大小变小.）</li><li>umd – 通用模块定义,以amd,cjs 和 iife 为一体,umd是amd和CommonJS的糅合,umd先判断是否支持Node.js的模块（exports）是否存在,存在则使用Node.js模块模式.</li></ul><p>所以我打包的文件无法通过commonJS方式来引入.</p><h3 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h3><p>libraryTarget就是问题的关键,通过设置该属性,这是可以控制 library 如何以不同方式暴露的选项.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'xieyezi-storage.js'</span>,</span><br><span class="line">    publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这样子,我们打包的文件就会支持各种规范了.这样子我以为就算完了,但是事实并非如此.我看了一下,打包之后的文件大小居然有2k.这么大？？</p><h3 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h3><p>在前面的考察中,我在选择打包工具的时候,我看见了Vue框架和React用的是什么打包工具,结果我发现,居然他们两都不是用的webpack,而是用的是一个叫做 <code>rollup</code> 的东西.于是我去查阅了rollup的官网:</p><blockquote><p>Rollup 是一个 JavaScript 模块打包器,可以将小块代码编译成大块复杂的代码,例如 library 或应用程序.Rollup 对代码模块使用新的标准化格式,这些标准都包含在 JavaScript 的 ES6 版本中,而不是以前的特殊解决方案,如 CommonJS 和 AMD.ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数,而你的项目不必携带其他未使用的代码.</p></blockquote><p>所以说,rollup就是专门用来打包library的,而webpack大多是用来打包应用程序的.</p><p>于是我愉快的开始了rollup的学习使用:<br>先安装:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global rollup</span><br></pre></td></tr></table></figure><p>在项目根目录新建一个rollup.config.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    input: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        file: <span class="string">'./dist/xieyezi-storage.js'</span>,</span><br><span class="line">        format: <span class="string">'umd'</span>,</span><br><span class="line">        name:<span class="string">'xieyezi-storage'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就是执行 <code>rollup c</code> ,成功打包.而且经过我的测试,能正常引入使用.我一看,才1k😂,开心的笑了.<br>然后我就打算用我们的<code>uglify</code>进行代码压缩:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i rollup-plugin-uglify -D</span><br></pre></td></tr></table></figure></p><p>在rollup.config.js配置引入:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; uglify &#125; <span class="keyword">from</span> <span class="string">'rollup-plugin-uglify'</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    input: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        file: <span class="string">'./dist/xieyezi-storage.js'</span>,</span><br><span class="line">        format: <span class="string">'umd'</span>,</span><br><span class="line">        name:<span class="string">'xieyezi-storage'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        uglify()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后重新运行 <code>rollup c</code> 进行打包,结果直接报错</p><p><img src="https://i.loli.net/2019/03/28/5c9c69facbebb.jpg" alt="IMG_0665.JPG"></p><p>我上去就是一顿谷歌加百度,原来uglify插件只支持es5的压缩.看来我只能另寻出路.我看见了 <code>terser</code> 这个插件,这个插件也能对代码进行压缩,支持es6.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i rollup-plugin-terser -D</span><br></pre></td></tr></table></figure></p><p>在rollup.config.js配置引入:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">'rollup-plugin-terser'</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    input: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        file: <span class="string">'./dist/xieyezi-storage.js'</span>,</span><br><span class="line">        format: <span class="string">'umd'</span>,</span><br><span class="line">        name:<span class="string">'xieyezi-storage'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        terser()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再次进行打包,成功打包！！！可是我们打包之后对代码只支持es6,我们还需要用 <code>babel</code> 进行转义:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line"><span class="string">"devDependencies"</span>: &#123;</span><br><span class="line"><span class="string">"babel-core"</span>: <span class="string">"^6.9.1"</span>,</span><br><span class="line"><span class="string">"babel-loader"</span>: <span class="string">"^6.2.4"</span>,</span><br><span class="line"><span class="string">"babel-plugin-add-module-exports"</span>: <span class="string">"^0.2.1"</span>,</span><br><span class="line"><span class="string">"babel-plugin-transform-es2015-modules-umd"</span>: <span class="string">"^6.12.0"</span>,</span><br><span class="line"><span class="string">"babel-plugin-transform-object-assign"</span>: <span class="string">"^6.22.0"</span>,</span><br><span class="line"><span class="string">"babel-plugin-transform-runtime"</span>: <span class="string">"^6.9.0"</span>,</span><br><span class="line"><span class="string">"babel-polyfill"</span>: <span class="string">"^6.22.0"</span>,</span><br><span class="line"><span class="string">"babel-preset-env"</span>: <span class="string">"^1.5.1"</span>,</span><br><span class="line"><span class="string">"babel-preset-es2015"</span>: <span class="string">"^6.9.0"</span>,</span><br><span class="line"><span class="string">"babel-preset-stage-2"</span>: <span class="string">"^6.5.0"</span>,</span><br><span class="line"><span class="string">"rollup-plugin-babel"</span>: <span class="string">"^3.0.7"</span>,</span><br><span class="line"><span class="string">"rollup-plugin-terser"</span>: <span class="string">"^4.0.4"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再进行<code>npm install</code><br>这里要注意,要使用babel,在rollup里面,必须安装完它所需对依赖,不能只安装 <code>rollup-plugin-babel</code>.必须安装完所有babel所需依赖.</p><p>完整的rollup.config.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">'rollup-plugin-terser'</span>;</span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">'rollup-plugin-babel'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    input: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        file: <span class="string">'./dist/xieyezi-storage.js'</span>,</span><br><span class="line">        format: <span class="string">'umd'</span>,</span><br><span class="line">        name:<span class="string">'xieyezi-storage'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        babel(&#123;</span><br><span class="line">            exclude: <span class="string">'node_modules/**'</span></span><br><span class="line">        &#125;),</span><br><span class="line">        terser()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在项目根目录新建.babelrc:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        [</span><br><span class="line">            &quot;env&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;modules&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;transform-object-assign&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行打包,打包成功<br>完整的package.json:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"xieyezi-storage"</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"1.0.4"</span>,</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"a package that encapsulates localStorage and sessionStorage"</span>,</span><br><span class="line"><span class="attr">"main"</span>: <span class="string">"dist/xieyezi-storage.js"</span>,</span><br><span class="line"><span class="attr">"module"</span>: <span class="string">"dist/xieyezi-storage.esm.js"</span>,</span><br><span class="line"><span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"web"</span>,</span><br><span class="line">    <span class="string">"localStorage"</span>,</span><br><span class="line">    <span class="string">"sessionStorage"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"author"</span>: <span class="string">"xieyezi"</span>,</span><br><span class="line"><span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line"><span class="attr">"git"</span>:&#123;</span><br><span class="line">    <span class="attr">"url"</span>:<span class="string">"https://github.com/xieyezi/webStorage"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.9.1"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^6.2.4"</span>,</span><br><span class="line">    <span class="attr">"babel-plugin-add-module-exports"</span>: <span class="string">"^0.2.1"</span>,</span><br><span class="line">    <span class="attr">"babel-plugin-transform-es2015-modules-umd"</span>: <span class="string">"^6.12.0"</span>,</span><br><span class="line">    <span class="attr">"babel-plugin-transform-object-assign"</span>: <span class="string">"^6.22.0"</span>,</span><br><span class="line">    <span class="attr">"babel-plugin-transform-runtime"</span>: <span class="string">"^6.9.0"</span>,</span><br><span class="line">    <span class="attr">"babel-polyfill"</span>: <span class="string">"^6.22.0"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-env"</span>: <span class="string">"^1.5.1"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-es2015"</span>: <span class="string">"^6.9.0"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-stage-2"</span>: <span class="string">"^6.5.0"</span>,</span><br><span class="line">    <span class="attr">"rollup-plugin-babel"</span>: <span class="string">"^3.0.7"</span>,</span><br><span class="line">    <span class="attr">"rollup-plugin-terser"</span>: <span class="string">"^4.0.4"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的项目结构如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── ./README.md</span><br><span class="line">├── ./dist</span><br><span class="line">│   ├── ./dist/xieyezi-storage.esm.js</span><br><span class="line">│   └── ./dist/xieyezi-storage.js</span><br><span class="line">├── ./package-lock.json</span><br><span class="line">├── ./package.json</span><br><span class="line">├── ./rollup.config.js</span><br><span class="line">├── ./babelrc</span><br><span class="line">└── ./src</span><br><span class="line">    └── ./src/index.js</span><br></pre></td></tr></table></figure></p><p>我按照 <code>es</code> 和 <code>umd</code> 打包了两次.</p><h3 id="将包上传至npm"><a href="#将包上传至npm" class="headerlink" title="将包上传至npm"></a>将包上传至npm</h3><p>先去npm注册一个账号,然后进入到根目录进行登录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm login</span><br><span class="line">Username: xieyezi</span><br><span class="line">Password: </span><br><span class="line">Email: (this IS public) 1435398529@qq.com</span><br><span class="line">Logged in as xieyezi on https://registry.npmjs.org/.</span><br></pre></td></tr></table></figure></p><p>注:输入密码的时候不会显示,只要最后显示Logged in as your nickName即可.<br>然后输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></p><p>它会提示你成功发布,并会给你发邮件.<br>进入到npm官网进行搜索我们发布的包,如果成功搜索到,则发布成功:<br><img src="https://i.loli.net/2019/03/28/5c9c7d748441f.png" alt="QQ20190328-155257@2x.png"></p><p>好了,接下来,进入到我自己的毕业设计的根目录:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xieyzi-storage</span><br></pre></td></tr></table></figure></p><p>在node_moudules里面查找 <code>xieyezi-storage</code> :<br><img src="https://i.loli.net/2019/03/28/5c9c7e592c74c.png" alt="QQ20190328-155537@2x.png"><br>成功找到,引入项目,成功地进行了引入✌️</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完成上面的这些工作,我花了前前后后差不多5天的时间,前期主要是在学习,后面才开始动手做.做的过程中遇到了很多 <code>error</code> 和 <code>bug</code> ,但是都是慢慢的解决了困难.我觉得最大的收获就是:很多时候,不是我们不会,只是我们不愿意主动去做而已.所以朋友吧,遇到自己不会的东西,撸起袖子就是干吧！！</p>]]></content>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> rollup </tag>
            
            <tag> webpack </tag>
            
            <tag> localStorage </tag>
            
            <tag> sessionStorage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>将本地项目同步至github</title>
      <link href="/2019/03/26/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%90%8C%E6%AD%A5%E8%87%B3github/"/>
      <content type="html"><![CDATA[<h3 id="将你的项目同步至github"><a href="#将你的项目同步至github" class="headerlink" title="将你的项目同步至github"></a>将你的项目同步至github</h3><p>注：此操作满足在你本机git已经配置到github环境下进行操作.<br> 先在项目根目录下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>  打开你的github首页,新建一个repository.<br>  复制你刚刚新建的repository的地址,像这样: <a id="more"></a><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/xieyezi/your-Repository.git</span><br></pre></td></tr></table></figure></p><p>  回到项目根目录,将你的本地项目和新建的repository联系起来:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/xieyezi/your-Repository.git</span><br></pre></td></tr></table></figure></p><p>  在当前根目录下新建.gitignore文件<br>  将你不需要同步的文件和目录写到.gitignore,例如:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">node_modules/</span><br></pre></td></tr></table></figure><p>  完成之后,到根目录:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add ./</span><br><span class="line">//当前目录下的有改动的文件全部加入,除开.gitignore备注的文件之外</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;commit information&apos;</span><br><span class="line">//这里将代码文件放入提交准备中， “commit information”字段填写自己的更新信息</span><br></pre></td></tr></table></figure><p>  最后一步:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><p>  到你的github里面查看,成功提交!!!!</p><p>  奉上两张git操作命令图😄:</p><p>  <img src="https://i.loli.net/2019/03/26/5c9a278b188be.png" alt="git命令1.png"></p><p>  <img src="https://i.loli.net/2019/03/26/5c9a278b03086.png" alt="git命令2.png"></p>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git基本知识</title>
      <link href="/2019/03/14/git%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <content type="html"><![CDATA[<h2 id="Git是什么？"><a href="#Git是什么？" class="headerlink" title="Git是什么？"></a>Git是什么？</h2><p>  Git 是一个开源的分布式版本控制系统.</p><h2 id="什么是版本控制？"><a href="#什么是版本控制？" class="headerlink" title="什么是版本控制？"></a>什么是版本控制？</h2><p>  版本控制是一种记录一个或若干文件内容变化,以便将来查阅特定版本修订情况的系统.</p><h3 id="集中化的版本控制系统和分布式版本控制系统"><a href="#集中化的版本控制系统和分布式版本控制系统" class="headerlink" title="集中化的版本控制系统和分布式版本控制系统"></a>集中化的版本控制系统和分布式版本控制系统</h3><p> 集中化的版本控制系统,都有一个单一的集中管理的服务器,保存所有文件的修订版本,而协同工作的人们都通过客户端连到这台服务器,取出最新的文件或者提交更新.也就是说,  <a id="more"></a>是多对一,如下图：</p><p>  <img src="https://i.loli.net/2019/03/14/5c8a2964c00a2.png" alt="未命名文件.png"></p><p> 这样做最显而易见的缺点就是服务器很容易发生单点故障而导致的全线奔溃.比如某一天服务器突然宕机,那么在宕机的这段时间内,所有的协同工作者均无法提交更新,无法实现协同工作,一旦服务器的磁盘受损,恰巧没有对文件进行备份,那就会发生数据丢失的惨剧.这个项目就相当于完全归零（<del>删库跑路</del>）🙃️<br> 分布式版本控制系统的客户端并不只提取最新版本的文件快照,而是把代码仓库完整地镜像备份下来.这么一来,任何一处协同工作用的服务器发生故障,事后都可以用任何一个镜像出来的本地仓库恢复.因为每一次的提取操作,实际上都是一次对代码仓库的完整备份,如下图：</p><p> <img src="https://i.loli.net/2019/03/14/5c8a2b75051e1.png" alt="未命名文件 (1).png"></p><h3 id="为什么使用Git？"><a href="#为什么使用Git？" class="headerlink" title="为什么使用Git？"></a>为什么使用Git？</h3><p>Git 是分布式的.这是 Git 和其它非分布式的版本控制系统,例如 svn,cvs 等,最核心的区别.分布式带来以下好处：</p><ol><li>更加安全,每个人的电脑上都是一个完整的版本库,独立负责自己的工作部分却又整体在推进项目的进行.只需把各自的修改推送给对方,就可以互相看到对方的修改了.</li><li>集中式版本控制系统,一旦中央服务器出了问题,所有人都无法工作.</li><li>分布式版本控制系统,每个人电脑中都有完整的版本库,所以某人的机器挂了,并不影响其它人.</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Windows-环境安装"><a href="#Windows-环境安装" class="headerlink" title="Windows 环境安装"></a>Windows 环境安装</h3><p>在Git 官方下载地址下载 exe 安装包.按照安装向导安装即可.</p><p>建议安装 Git Bash 这个 git 的命令行工具.</p><h3 id="Mac-环境安装"><a href="#Mac-环境安装" class="headerlink" title="Mac 环境安装"></a>Mac 环境安装</h3><p>在Git 官方下载地址下载 mac 安装包.按照安装向导安装即可.</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p> Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量.</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p> 当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址. 这样做很重要,因为每一个 Git 的提交都会使用这些信息,并且它会写入到你的每一次提交中,不可更改：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;xieyezi&quot;</span><br><span class="line">$ git config --global user.email xieyezi@example.com</span><br></pre></td></tr></table></figure></p><p> 在你每一次提交你代码更新信息时,会携带你的用户信息</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p> 这个文件里配置的文件或目录,会自动被 git 所忽略,不纳入版本控制.项目在进行开发时,经常会产生一些临时文件或者依赖文件,例如<code>npm node_modules</code>等,这些没有必要放入git服务器进行托管,就会被<code>.gitignore</code>纳入.</p><h3 id="git基本原理简介"><a href="#git基本原理简介" class="headerlink" title="git基本原理简介"></a>git基本原理简介</h3><h4 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h4><p>   当你一个项目到本地或创建一个 git 项目,项目目录下会有一个隐藏的 .git 子目录.这个目录是 git 用来跟踪管理版本库的,千万不要手动修改.</p><h4 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h4><p>   在 git 中,你的文件可能会处于三种状态之一：</p><ul><li>已修改（modified） - 已修改表示修改了文件,但还没保存到数据库中.</li><li>已暂存（staged） - 已暂存表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中.</li><li>已提交（committed） - 已提交表示数据已经安全的保存在本地数据库中.    </li></ul><h4 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h4><p>   与文件状态对应的,不同状态的文件在 Git 中处于不同的工作区域.</p><ul><li>工作区（working） - 当你 git clone 一个项目到本地,相当于在本地克隆了项目的一个副本.工作区是对项目的某个版本独立提取出来的内容. 这些从 Git 仓库的压缩数据库中提取出来的文件,放在磁盘上供你使用或修改.</li><li>暂存区（staging） - 暂存区是一个文件,保存了下次将提交的文件列表信息,一般在 Git 仓库目录中. 有时候也被称作‘索引’,不过一般说法还是叫暂存区.</li><li>本地仓库（local） - 提交更新,找到暂存区域的文件,将快照永久性存储到 Git 本地仓库.</li><li>远程仓库（remote） - 以上几个工作区都是在本地.为了让别人可以看到你的修改,你需要将你的更新推送到远程仓库.同理,如果你想同步别人的修改,你需要从远程仓库拉取更新.</li></ul>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决移动端300ms延迟的问题</title>
      <link href="/2019/03/03/%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AF300ms%E5%BB%B6%E8%BF%9F%E7%82%B9%E5%87%BB%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h3 id="移动端300ms延迟"><a href="#移动端300ms延迟" class="headerlink" title="移动端300ms延迟"></a>移动端300ms延迟</h3><p>  移动端浏览器click事件为什么会有300ms的延迟呢？因为在手机上有个双击方案：在手机上快速点击两下，实现页面放大；再次双击，恢复到原始比例。<br>  那它是如何实现的呢？浏览器在捕捉到第一次点击事件后，会等待一段时间，如果在这段时间内，用户没有再次进行点击操作的话，就执行单击事件；如果用户进行了第二次点击操作的话，就会执行双击事件。这段等待的时间大约300ms。<a id="more"></a><br>  如果我们需要开发Web APP，那我们肯定不希望有这个延迟。因为延迟会造成请求的延迟，从而降低了用户的使用体验。</p><h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p>  目前我已知的有两种方法：</p><ol><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1,minimum-scale=1, user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>width=device-width 宽度为设备宽度 initial-scale=1 初始比例为1 maximum-scale=1 最大比例为1 minimum-scale=1 最小比例为1 user-scalable=no 用户不能进行放大缩小</p></li><li><p>引入第三方库fastclick</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install fastclick --save</span><br></pre></td></tr></table></figure><p>因为所有页面都要引入，所以在入口处统一引入就可以了，再将其绑定到body这个dom上即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fastClick <span class="keyword">from</span> <span class="string">'fastclick'</span></span><br><span class="line">fastClick.attach(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue cli3+Hubuilder将项目打包为App</title>
      <link href="/2019/02/26/Vue-cli3.0+Hbuilder%E6%89%93%E5%8C%85App/"/>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>   现在跨平台的开发越发的火了起来。前端能做到的事情也越来越多，App再也不用完全依靠安卓原生开发了。现在开发app的方式都是内核是前端开发，然后再给项目套一个安卓的外壳，即可实现app的开发。</p><h3 id="Vue开发app如何打包？"><a href="#Vue开发app如何打包？" class="headerlink" title="Vue开发app如何打包？"></a>Vue开发app如何打包？</h3><p>   现在最新的脚手架为Vue-cli3,构建出来的项目结构十分明了简单。配置文件只需一个Vue.config.js即可搞定。<a id="more"></a><br>    先到Vue.config.js里面添加：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 选项...,</span></span><br><span class="line">    baseUrl: <span class="string">'./'</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">8080</span>, <span class="comment">// 端口号</span></span><br><span class="line">        host: <span class="string">'localhost'</span>,</span><br><span class="line">        https: <span class="literal">false</span>, <span class="comment">// https:&#123;type:Boolean&#125;</span></span><br><span class="line">        open: <span class="literal">true</span>, <span class="comment">//配置自动启动浏览器</span></span><br><span class="line">        <span class="comment">// proxy: 'http://localhost:4000' // 配置跨域处理,只有一个代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">''</span>,<span class="comment">//后端接口地址</span></span><br><span class="line">                ws: <span class="literal">true</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,<span class="comment">//是否允许跨域</span></span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'^/api'</span>: <span class="string">''</span>   <span class="comment">//直接用'api/接口名'进行请求.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// 配置多个代理</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><p>   将<code>baseUrl</code>改为<code>&#39;./&#39;</code><br>   然后用webpack将项目打包为dist文件.</p><p>   <img src="https://i.loli.net/2019/02/26/5c750a692d307.png" alt="QQ20190226-174159@2x.png"></p><p>   打开Huilder<br>   点击打开目录<br>   找到刚刚的dist文件夹，取好项目名称。</p><p>   <img src="https://i.loli.net/2019/02/26/5c750a8d8b32d.png" alt="QQ20190226-174216@2x.png"></p><p>   右点击项目，将项目转换为App</p><p>   <img src="https://i.loli.net/2019/02/26/5c750e8683040.png" alt="QQ20190226-174241@2x.png"></p><p>   然后进行mainfest文件配置，制作app图标和启动页<br>   点击进行云打包进行打包</p><p>   <img src="https://i.loli.net/2019/02/26/5c750ee452841.png" alt="QQ20190226-174303@2x.png"></p><p>   然后下载打包好之后的.apk文件即可。</p>]]></content>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Hubuilder </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的2018，都做了些什么？</title>
      <link href="/2019/01/17/%E6%88%91%E7%9A%842018%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h3 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h3><p>   我先自己解释一下，在上次更新博客之后，我长达一个月没有更新自己的博客的原因。我上个月15号去了昆明某军区，作为外援，在军区秘密开发一个月。这一个月以来，每天都在加班，所以根本没有时间更新自己的博客。</p><h3 id="为什么选择前端？"><a href="#为什么选择前端？" class="headerlink" title="为什么选择前端？"></a>为什么选择前端？</h3><p>   2018年，应该算是我人生的一个转折点吧。特别是下半年，算是正式走入社会。<a id="more"></a><br>   上半年，在学校学习了专业课，参加了一次市级的比赛，侥幸获得了一个三等奖。虽然是三等奖，但是也给了我莫大的鼓励。让我真正确定了我想往哪个方向发展。我选择了前端。前端早已经不是像以前那样写写页面就行了，现在前端越来越趋向工程化、标准化，开始有了一整套的标准。在18年，前端开发开始出现三足鼎立的局面。Vue、React、Angular开始成为前端开发的主流。前端能做的事情越来越多，Node.js已经能胜任大部分后端开发工作。其实说到底，我为什么喜欢web开发呢？我喜欢所见即所得，相较于后端和算法类的开发，我做前端会更让我有成就感，我发自内心地热爱前端，就像我热爱音乐那样。基本上我是今年上半年才确定自己以后要发展的方向。</p><h3 id="做了什么？"><a href="#做了什么？" class="headerlink" title="做了什么？"></a>做了什么？</h3><p>   今年下半年，我几乎横跨了整个中国，我先是去了上海，在上海的连尚网络实习了三个月。这三个月期间，我正式开始学习vue，接触了webpack，接触了Niginx等等。我在公司的大数据平台部门，主要负责开发数据可视化。参与了公司未开源项目“玄鸟”的开发，参与了公司未开源项目“沙箱”的开发。实习完了之后，我没有选择继续留在上海，一是因为我不喜欢上海那样的生活节奏，二是因为我个人原因，想离家近一点。于是12月初，我回到了重庆，参加了最后一次秋招，侥幸，要我的公司还挺多。于是选择了成都的一家公司-”东信北邮“。准备明年三月份去报到上班了。当我还在准备去报个驾校的时候，没想到我又去了昆明，真的是穿越了中国东西部。在昆明的一个月时间里面，我一直都在上班。是一个军方项目，时间十分的紧张，于是一天都没有休息过。然后就到了19年1月11号，我终于回重庆了。</p><h3 id="收获了什么？"><a href="#收获了什么？" class="headerlink" title="收获了什么？"></a>收获了什么？</h3><p>   特别是下半年，我收获颇多，不光是技术上的提升，包括生活、世界观、人生观。在上海的时候，一个人上下班、一个人上下班，怎么说着说着就开始感性起来了。不过生活真的很困难，为了赚一点点钱，真的很不容易。我们得承受莫大的孤独和难过，却也只能咬牙坚持！我可以毫不顾忌地讲，我在上海，哭过。前一个月在昆明，也是因为天天加班，导致我精神压力很大，甚至还进了医院，也算体验了一番生死。人总是要在这种时候才能明白一些道理。但是也算挺过来了。以后要注意锻炼身体啦，别这样拼命了。只不过值得很庆幸的是，我认识了很多很多的人，在上海的那些前辈、偶尔回来参加生日会的老板-<a href="https://baike.baidu.com/item/%E9%99%88%E5%A4%A7%E5%B9%B4/15497204?fr=aladdin" target="_blank" rel="noopener">陈大年</a>、昆明认识的战友。他们教会了我很多，怎么去看待这个世界，怎么去思考这个世界。比起那些在技术上的提升，我觉得自己收获得最大的就是这些朋友了。</p><h3 id="思考了些什么？"><a href="#思考了些什么？" class="headerlink" title="思考了些什么？"></a>思考了些什么？</h3><p>   经过半年，我感觉我不再是曾经那个想法简单的自己了。<br>   1.20岁的时候，遇见喜欢的姑娘，就抱着一定要去追到手的心态，一定要去痛彻心扉一番才肯罢休。还喝着酒大声的对自己说：这就是爱情。现在想来，那个时候真的太幼稚。我现在仍然不知道什么是爱情，就算知道自己喜欢的姑娘不喜欢自己，也不会去强求了，我现在穷小子一个，我凭什么要人家跟我在一起？放不下的放得下的，不都得放下吗？顶多是多年后，可能某一天想起这个姑娘，我会说，哦，那个姑娘啊，爱过！哈哈。写着写着居然笑了，学会自我调侃了。<br>   2.我其实想不通爷爷奶奶是如何老去的。特别是奶奶，17年春节开始，大年初二就住进了医院，之后的一年里，经常反复进出医院。好像是很多病魔一下子全部找到了她。实际上在我的印象中，她一直是50岁的年纪，那个年纪，我们老家盖新房子，她每顿饭都能吃两大碗，一周平均要拿竹鞭子打我三四次，那个时候的健康程度，完全从我屁股上的一丝一丝的伤痕看得出来。她是三个妹妹，一个弟弟的大姐，她是三个孩子的妈妈，两个孩子的外婆，她还是我的奶奶。她是个女强人+操心狂。所有的跟她有关的人只要有事，她都会操心。今天妹妹跟丈夫吵架啦、明天姑姑又怎么样怎么样啦、扒拉扒拉的，她都喜欢操心。但是我前一段时间突然发现，这些她都不再过问了。我是什么时候发现她真正老了呢？今年七月份回过家一次，仅是匆匆一别。以前但凡我出门，她都会送到我上车为止，才舍得离去，但这次，她居然叫我自己走。那一瞬间我惊觉：她老了。一下子背变佝偻了，肤色一下子变黑了。 我不留在上海的原因之一就是我希望我以后可以一个月回家看她一次。不知道为什么，我在上海的时候，总有一种，抛弃了爷爷奶奶的负罪感，我想要多些时间去陪他们。<br>   他们虽然越发的老去，但是他们的爱情，总是让我动容，我经常问奶奶，你爱爷爷吗，然后奶奶都是拒绝回答，呵呵呵的傻笑，还打向爷爷，但是我在她眼里，我看见的就是爱情。时间在他们两个人之间，只能带走他们的容颜，但是带不走的是他们之间的爱。<br>   只不过我还是想不明白他们为什么会变老，许是被我“爷爷奶奶”喊多了，就喊老了？</p><h3 id="接下来做什么？"><a href="#接下来做什么？" class="headerlink" title="接下来做什么？"></a>接下来做什么？</h3><p>   经过了2018年，我来到了人生的分水岭了。就要自己出去赚钱养活自己了。接下来的一年里，我最大的愿望就是希望家人都健健康康。技术上准备学React、Node.js、Springoot、看看有没有实力能够封装一个自己的UI框架！<br>   结尾奉上自己的Github 2018提交记录：</p><p>   <img src="https://i.loli.net/2019/01/17/5c4093d3d7b70.png" alt="我的Git2018记录"></p><p>  再推荐两个工具：<br>  <a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a> 一个可以撰写接口文档的利器<br>  <a href="http://www.gitblit.com/" target="_blank" rel="noopener">GitBlit</a> 一个可以搭建自己的Git服务器的利器<br>  最后，祝大家身体健康！</p>]]></content>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>better-scroll插件初始化后没有效果?</title>
      <link href="/2019/01/17/better-scroll%E6%8F%92%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C%EF%BC%9F/"/>
      <content type="html"><![CDATA[<h3 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h3><p>   最近做开发,用到了一个很著名的Vue插件-<a href="https://ustbhuangyi.github.io/better-scroll/#/" target="_blank" rel="noopener">better-scroll</a>.这个插件主要是用来解移动端各种滚动页面的需求.我在项目中想要一个页面的滚动效果,引入了这个插件之后,按照作者的方法进行了初始化,但是仍然无法实现.经过我不断的谷歌,终于找到了解决的办法.下面我来介绍一下这个插件的具体的用法.<br>   <a id="more"></a></p><h3 id="安装及其引入"><a href="#安装及其引入" class="headerlink" title="安装及其引入"></a>安装及其引入</h3>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install better-scroll --save</span><br></pre></td></tr></table></figure><p>   在所需组件引入:<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">'better-scroll'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="插件的理解"><a href="#插件的理解" class="headerlink" title="插件的理解"></a>插件的理解</h3><p>   其实这个插件实现滚动原理很简单.我们先来看一下这个这个插件的html结构:<br>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里可以放一些其它的 DOM，但不会影响滚动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  上面的代码中 better-scroll 是作用在外层 wrapper 容器上的,滚动的部分是 content 元素.意思就是说,content会在wrapper上实现滚动.为什么content就能滚动呢?,我们来看下面一张图片(截自官网):</p><p>  <img src="http://static.galileo.xiaojukeji.com/static/tms/shield/scroll-4.png" alt="Github需求" title="GitHub需求"></p><p>  也就是说,当content的内容的高度超过wapper高度的时候,会出现滚动效果,也就是当我们的视口展示不下内容的时候,会通过滚动条的方式让用户滚动屏幕看到剩余的内容.但是这里要注意的是,better-scroll 只处理容器（wrapper）的第一个子元素（content）的滚动,其它的元素都会被忽略.<br>  比如下面这样的代码:<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"other&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">   &lt;/div&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">   &lt;ul class="</span><span class="attr">content</span>"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  在上面的代码中,在warpper中实现滚动效果是ul吗?当然不是,这里会滚动other.我们来看看源码:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.scroller就是滚动的内容，this.wrapper是容器</span></span><br><span class="line">  <span class="keyword">this</span>.scroller = <span class="keyword">this</span>.wrapper.children[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>  可以看出来,只有warpper的第一个孩子才会实现滚动效果.所以我们应该把需要滚动的内容都放置在一个容器里面,作为warpper的第一个孩子.</p><h3 id="插件的初始化"><a href="#插件的初始化" class="headerlink" title="插件的初始化"></a>插件的初始化</h3><p>  注:这里我只介绍在vue中的情况.<br>  template:<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span> <span class="attr">ref</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  js:<br>  我们在methods中封装一个initNormal方法:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">initNormal()&#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.scroll) &#123;</span><br><span class="line">       <span class="keyword">this</span>.scroll = <span class="keyword">new</span> BScroll(<span class="keyword">this</span>.$refs.wrapper, &#123;</span><br><span class="line">           click: <span class="literal">true</span>,</span><br><span class="line">           probeType: <span class="number">3</span></span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">//console.log(this.scroll);</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.scroll.refresh();</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  那么我们应该在什么时候调用这个方法进行初始化呢?<br>  通常的做法是你的异步请求都完成以后,才进行对better-scroll的初始化.如果不这样做的话,better-scroll无法正确取到content的高度.从而无法实现滚动.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v.$axios.get(<span class="string">'api/toplist/artist'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//console.log(response.datalist.artists);</span></span><br><span class="line">      <span class="keyword">if</span> (response.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.singerList = response.data.list.artists;</span><br><span class="line">          <span class="comment">//数据加载完成，可以进行初始化了</span></span><br><span class="line">           <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">                 <span class="keyword">this</span>.initNormal();</span><br><span class="line">              &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>  上面的代码中,调用了<code>$nextTick</code>方法,就是为了确保将bettre-scroll的初始化放置在异步请求完成之后.<br>  接下来还有最重要的一步,我也是卡在这一步.上面我已经说过了,只有wapper的高度小于content高度的时候,才会出现滚动效果,那意味着我们必须给wapper和content设置高度.其实content的高度我们不需要管.因为在初始化的时候,better-scroll会自动将高度计算出.那么我们需要对wapper设置高度,但是问题是,在移动端,用户用手滑动屏幕,我们如何能得知他滑动的高度,从而给warpprt赋值呢?其实很简单,用css样式就可以实现:<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>  然后重新启动项目,就能实现想要的滚动效果.就是这样简单的两行代码,居然困扰我这么久,然而我当时还想着跟随滚动去计算高度,醉了.</p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用githubPage+docsify搭建项目文档</title>
      <link href="/2018/12/11/%E5%88%A9%E7%94%A8githubPage+docsify%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这段时间从上海离职回到重庆了,所以一直没有更新我的博客和GitHub,为自己的自律打负分.我可以说最近事情繁多,但是这也不能成为我懒惰的理由.</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>  有时候,我们做了一个项目,我们自己能看懂项目,但是我们需要给他人提供API文档,但是我们又没有多余的服务器和域名,这个时候咋办？那么我们就可以用到GitHubPage+<a href="https://docsify.js.org/#/" target="_blank" rel="noopener">docsify</a>搭建我们的项目文档.<a id="more"></a></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>  进入你项目的根目录,在命令行输入以下命令创建项目文档目录(docs):</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docsify init ./docs</span><br></pre></td></tr></table></figure><p>  这个命令执行完成之后,你会看见你的项目文档多了一个docs目录.你的项目文档就可以写在这个目录里面.<br>  进入这个目录会看见以下文件:</p><ul><li>index.html 入口文件</li><li>README.md 会做为主页内容渲染</li><li>.nojekyll 用于阻止 GitHub Pages 会忽略掉下划线开头的文件</li><li>直接编辑 docs/README.md 就能更新网站内容,当然也可以写多个页面.</li></ul><p>  在README.md写你的项目文档就可以了.</p><p>  预览文档:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docsify serve docs</span><br></pre></td></tr></table></figure></p><p>  如果你觉得构建得差不多了,你就可以将它放置到GitHub上面.</p><p>  首先你得保证你的项目已经托管到GitHub上面.<br>  推荐直接将文档放在 docs/ 目录下,在设置页面开启 GitHub Pages 功能并选择 master branch /docs folder 选项：<br>  在GitHub里面,点击进入项目:</p><p>  <img src="https://i.loli.net/2018/12/11/5c0f09dc82ac1.png" alt="QQ20181211-084924@2x.png"></p><p>  设置master branch /docs folder:</p><p>  <img src="https://i.loli.net/2018/12/11/5c0f0a0978667.png" alt="QQ20181211-084951@2x.png"></p><p>  完成之后,它会提示你的文档目录已经生成,并且已经可以通过GitHub的子域名进行访问了.<br>  比如我的音乐<a href="https://xieyezi.github.io/myMusic/#/" target="_blank" rel="noopener">webApp项目文档</a>.</p>]]></content>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> docsify </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue.$nextTick解析</title>
      <link href="/2018/11/18/Vue.$nextTick%E8%A7%A3%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>这篇博文全是干货,内容很长,但是值得收藏！！！</p><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>   我最近在做一个自己的音乐Web App,期间遇到不少瓶颈,这次记录一下我困扰了将近一周的问题.我在一个组件内点击了播放按键,将这个点击事件派发到父组件,然后传入ID到player组件内,进行异步请求,获取到该首音乐的播放地址,然后通过vue.$ref去调用audio.play()方法,经过调试发现,在谷歌浏览器、火狐浏览器等都能正常播放,但是唯独苹果旗下的safari播放器不能播放.请看代码:<br> <a id="more"></a><br>dom部分：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">:src</span>=<span class="string">"songurl"</span> <span class="attr">ref</span>=<span class="string">"audio"</span> @<span class="attr">canplay</span>=<span class="string">"ready"</span> @<span class="attr">error</span>=<span class="string">"error"</span> @<span class="attr">timeupdate</span>=<span class="string">"updateTime"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里的”:src=songurl”,我是在data里面初始化了一个’songurl’ :</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                songurl: <span class="string">''</span>,</span><br><span class="line">                songReady: <span class="literal">false</span>,</span><br><span class="line">                currentTime: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure></code></pre><p>watch部分：</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">            currentSong() &#123;</span><br><span class="line">                <span class="keyword">var</span> v = <span class="keyword">this</span>;</span><br><span class="line">                v.getSongUrl(v.currentSong.id).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        v.$refs.audio.play();</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            playing(newPlaying) &#123;</span><br><span class="line">                <span class="keyword">var</span> v = <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">const</span> audio = v.$refs.audio;</span><br><span class="line">                v.getSongUrl(v.currentSong.id).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    newPlaying ? audio.play() : audio.pause();</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure></code></pre><p>可以看到,我是先去调用了v.getSongUrl( ) 这个方法去获取歌曲URL,这个promise执行完成之后,然后再去播放歌曲.<br>以下为getSongUrl( ) 方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getSongUrl(id) &#123;</span><br><span class="line">                <span class="keyword">var</span> v = <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">return</span> v.$axios.get(<span class="string">'api/song/url'</span>, &#123;</span><br><span class="line">                    params: &#123;</span><br><span class="line">                        id: id</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (response.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">                        v.songurl = response.data.data[<span class="number">0</span>].url;</span><br><span class="line">                        <span class="comment">//console.log("地址：" + v.songurl);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(error);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure></p><p>所以就是,我先去异步请求,然后将获取的url赋值给data里面的songurl,然后绑定到audio的src上面,然后再去调用audio.play. 但是safari就是不能播放.</p><h3 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h3><p>遇到问题,先进行思考,为什么谷歌浏览器等一众浏览器都能正常播放,唯独safari不能？是不是safari有什么特别之处？于是我去搜索了一番,一查还真是,请看：</p><p><img src="https://i.loli.net/2018/11/18/5bf103da21030.png" alt="QQ20181118-141626@2x.png"></p><p>safari对播放做了限制,除非用户自己进行了交互操作,但是去调用<code>audio.play()</code>,而我在这里,是先进行了异步请求,才去执行了这个<code>audio.play()</code>,所以不能播放.说起来safari还真是尿性,为了防止用户损失流量,就做了这个限制,那有什么办法解决呢？请看：</p><p><img src="https://i.loli.net/2018/11/18/5bf105f1cae71.png" alt="QQ20181118-142537@2x.png"></p><p>意思是说,官方还是没有解除这个限制.这里还说到,Apple 在 iOS 4.2.1 中修复了异步请求之后播放的功能,所以这种变通方法在 iOS 4.2.1 和后续版本中是不起作用的.终于找到问题所在,原来就是不能这样实现.所以我就必须重构自己的业务逻辑,不能在播放之前进行异步请求,于是我将获取歌曲URL的操作放置到另一个组件内,然后利用props传递到player组件里面来,简单来说我将异步请求放到前面去实现了.然而这样就能播放了吗？答案是还是不能!!!我懵逼了,我不是将异步请求放置到前面去实现了吗,为什么还是不能实现？于是我去搜索了一下,原来有一个<code>Vue.$nextTick</code>方法.那么这个方法的作用是什么？请看：<br><img src="https://i.loli.net/2018/11/18/5bf10ec8e657b.png" alt="QQ20181118-150210@2x.png"><br>意思是说,我可能数据还没加载好,就去更新dom了,所以应该将更新dom的操作放置到<code>Vue.$nextTick</code>方法中,这样就可以保证将更新dom的操作放置到异步请求之后去实现了:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">           currentSong() &#123;</span><br><span class="line">               <span class="keyword">var</span> v = <span class="keyword">this</span>;</span><br><span class="line">               v.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                   v.$refs.audio.play();</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;,</span><br><span class="line">           playing(newPlaying) &#123;</span><br><span class="line">               <span class="keyword">var</span> v = <span class="keyword">this</span>;</span><br><span class="line">               <span class="keyword">const</span> audio = v.$refs.audio;</span><br><span class="line">               v.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                   newPlaying ? audio.play() : audio.pause();</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure></p><p>然而这样做之后就能播放了吗？答案是还是不能！！为什么呢？</p><h3 id="继续探究"><a href="#继续探究" class="headerlink" title="继续探究"></a>继续探究</h3><p>那为什么加了<code>Vue.$nextTick</code>方法还是无法实现播放?我们应该去研究研究Vue的这个方法,但是在这之前,我们先来看看JS的运行机制:<br>来自阮一峰的<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">一篇文章</a>,大致分为以下几个步骤:</p><ol><li>所有同步任务都在主线程上执行,形成一个执行栈（execution context stack）.</li><li>主线程之外,还存在一个”任务队列”（task queue）.只要异步任务有了运行结果,就在”任务队列”之中放置一个事件.</li><li>一旦”执行栈”中的所有同步任务执行完毕,系统就会读取”任务队列”,看看里面有哪些事件.那些对应的异步任务,于是结束等待状态,进入执行栈,开始执行.</li><li>主线程不断重复上面的第三步.           </li></ol><p> 主线程的执行过程就是一个 <code>tick</code>,而所有的异步结果都是通过 “任务队列” 来调度被调度. 消息队列中存放的是一个个的任务（task）. 规范中规定 task 分为两大类,分别是 <code>macro task</code> 和 <code>micro task</code>.在浏览器环境中,常见的 <code>macro task</code> 有 <code>setTimeout</code>、<code>MessageChannel</code>、<code>postMessage</code>、<code>setImmediate</code>；常见的 <code>micro task</code> 有 <code>MutationObsever</code> 和 <code>Promise.then</code>.</p><p> 回到Vue的<code>nextTick</code>,先生介绍一下这个方法的使用场景:<br> vue将异步调用的方法其实是push到一个队列里面,然后内部调用一次nextTick,统一去更新dom,所以数据到DOM数据的变化要下一个tick才能完成.<br> 在2.5以上的版本中,它调度的优先顺序为:<br> <code>setImmediate</code> -&gt; <code>MessageChannel</code> -&gt; <code>setTimeout</code></p><h3 id="对-audio-播放的影响"><a href="#对-audio-播放的影响" class="headerlink" title="对 audio 播放的影响"></a>对 audio 播放的影响</h3><p>知道了调度顺序之后,那到底nextTick是如何影响adio的？经过我的测试,是<code>MessageChannel</code>影响了audio的播放.就是因为在2.5版本以上,<code>nextTick</code>优先使用<code>MessageChannel</code>,造成了audio不能播放.</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>知道了什么原因,我们就可以解决问题了,那我们在这里跳过<code>MessageChannel</code>,不就行了吗.我直接将全局的<code>MessageChannel</code>禁用掉:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.MessageChannel = noop</span><br><span class="line"><span class="built_in">window</span>.setImmediate = noop</span><br></pre></td></tr></table></figure></p><p>这样就跳过了MessageChannel,我再运行项目跑了一下,完美解决!!</p>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>promise连续调用的问题</title>
      <link href="/2018/11/15/promise%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h3 id="问题的背景"><a href="#问题的背景" class="headerlink" title="问题的背景"></a>问题的背景</h3><p>  最近在做自己的项目的时候,遇到了一个问题.我在组件里面监听了一个对象的变化.一旦发生变化.先通过这个对象的ID去进行异步请求.获取到一个属性:URL(播放地址).然后将这个属性绑定到audio的src属性上.然后再去利用this.$refs获取dom调用radio.play方法.<br>  <a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">currentSong() &#123;</span><br><span class="line">             <span class="keyword">var</span> v = <span class="keyword">this</span>;</span><br><span class="line">             v.loadSongUrl(id);</span><br><span class="line">             v.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                 v.$refs.audio.play();</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;,</span><br></pre></td></tr></table></figure><h3 id="遇见的问题"><a href="#遇见的问题" class="headerlink" title="遇见的问题"></a>遇见的问题</h3><p>  vue异步请求成功之后,还没绑定数据就立即去执行获取dom元素了.</p><h3 id="示意流程"><a href="#示意流程" class="headerlink" title="示意流程"></a>示意流程</h3><p>  正确:  currentSong变化 -&gt; 进行异步请求 -&gt; 绑定数据到dom -&gt; 获取dom<br>  错误:(遇到的情况)  currentSong变化  -&gt; 进行异步请求 -&gt; 获取dom -&gt;绑定数据到dom</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>   为什么会有这样的情况出现？其实这里是连续的异步调用.在第一次进行异步请求URL之后.在同步队列中.我的异步请求完成之后会加入到‘任务队列’中.所以会马上去执行同步队列的任务.</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v.loadSongUrl(id).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    v.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                  v.$refs.audio.play();</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  同时必须给loadSongUrl添加return:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> v.$axios.get(<span class="string">'api/song/url'</span>, &#123;</span><br><span class="line">       params: &#123;</span><br><span class="line">           id: songsIds</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//console.log(response.data.data);</span></span><br><span class="line">       <span class="keyword">if</span> (response.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">           songUrlList = response.data.data;</span><br><span class="line">           <span class="comment">//console.log(songUrlList);</span></span><br><span class="line">           v.manageSongList(list,songUrlList);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(error);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>  在ES6中.有封装promise.then()方法.这个方法保证多个异步请求按序进行.回调函数中会把上一个then中返回的值当做参数值供当前then方法调用.then方法执行完毕后需要返回一个新的值给下一个then调用（没有返回值默认使用undefined）.也就是说.每个then只可能使用前一个then的返回值.有了这个方法.就能保证去获取dom之前.先去绑定dom的效果.</p>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> JS </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nginx给tomcat配置反向代理</title>
      <link href="/2018/11/06/nginx%E7%BB%99tomcat%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <content type="html"><![CDATA[<h3 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h3><p>   可以利用nginx作为分发服务器,给tomcat下面的项目做代理.</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>  在nginx根目录下面的conf文件夹下,打开nginx.conf进行编辑(在http内添加如下内容):<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 设置tomcat代理</span><br><span class="line"> upstream tomcat &#123;</span><br><span class="line">       server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> server &#123;</span><br><span class="line">     listen <span class="number">80</span>;</span><br><span class="line">     server_name www.xieyezi.com;</span><br><span class="line">     location / &#123;</span><br><span class="line">         proxy_set_header        Host $host;</span><br><span class="line">         proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">         proxy_pass http:<span class="comment">//tomcat;</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>  <a id="more"></a><p> 在nginx根目录打开命令行,输入:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p> 注意这里有几个要注意的点,server_name配置的域名必须与tomcat的serve.xml里面的Host的name字段要一致.<br> 完成了重启之后,就可以访问<code>www.xieyezi.com\项目名</code> ,访问到tomcat服务器下面到项目.<br> 那么实现分布式反向代理的原理是什么呢,请看下面这个图:</p><p><img src="https://i.loli.net/2018/11/06/5be1b215b14da.png" alt="寻找终点 (1).png"></p><p>看了上面的图就很清楚了.</p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nginx解决vue项目在生产环境的跨域问题</title>
      <link href="/2018/11/06/nginx%E8%A7%A3%E5%86%B3vue%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h3 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h3><p>   我最近做项目,我在前端使用了vue开发,使用vue-cli3搭建项目,在开发的过程中,在开发环境中遇到了跨域的问题,我在vue.config.js配置了proxy,然后解决了问题.但是项目总归要上线,我运行了<code>npm run build</code>之后生成了dist文件夹.由于我的服务器容器是tomcat,所以刚开始我在tomcat的webapps文件夹下面新建了一个项目名vuemusic,然后将dist文件夹下面的所有东西拷贝至webapps下面,然后去conf文件夹配置了server.xml,然后我很开心的打开浏览器,输入地址<code>www.xieyezi.com/vuemusic</code>进行访问,这个时候出现一个问题,请求不到后端数据.<br>   <a id="more"></a></p><h3 id="问题的分析"><a href="#问题的分析" class="headerlink" title="问题的分析"></a>问题的分析</h3><p>   我认真的想了一下,这个项目是前后端分离的项目,我将前端代码放置在tomcat的webapps下面,我的tomcat配置的是80端口,但是我的后端服务采用的是node.js,然后走的是3000端口,但是去访问网站的时候会默认访问同源位置,所以出现了端口跨域的问题.</p><h3 id="解决的思路"><a href="#解决的思路" class="headerlink" title="解决的思路"></a>解决的思路</h3><p>   找到了问题,那我们就可以思考一下怎么去解决问题.<br>   有两种解决思路:</p><ul><li>一是在后端服务模块设置允许跨域,但是我对node.js不是特别熟悉,所以放弃了这个方法.</li><li>二是找到一个可以实现跨域的代理方法.我在网上搜索,大家都推荐使用nginx去实现生产环境跨域问题.      </li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>  所以就使用nginx来解决跨域问题.<br>  去[nginx官网]下载安装好nginx.<br>  到ngix根目录点击nginx.exe启动ngix服务器.<br>  然后将刚刚在webapps文件夹下新建的vumusic文件夹拷贝至nginx目录下的html目录下(如图):</p><p>  <img src="https://i.loli.net/2018/11/06/5be168751fc06.png" alt="QQ20181106-180932@2x.png"></p><p>  打开conf文件夹下面的nginx.conf进行编辑:<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 设置vue项目</span><br><span class="line"> server &#123;</span><br><span class="line">     listen  <span class="number">8080</span>;</span><br><span class="line">     server_name www.xieyezi.com;</span><br><span class="line"></span><br><span class="line">     #charset koi8-r;</span><br><span class="line">     #access_log  logs/host.access.log  main;</span><br><span class="line">     location / &#123;</span><br><span class="line">         root   html/vuemusic;</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    #设置代理转发</span><br><span class="line">     location /api/ &#123;</span><br><span class="line">       proxy_pass  http:<span class="comment">//localhost:3000/;</span></span><br><span class="line">     &#125;</span><br><span class="line">     #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">     # redirect server error pages to the static page /50x.html</span><br><span class="line">     #</span><br><span class="line">     error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">     location = <span class="regexp">/50x.html &#123;</span></span><br><span class="line"><span class="regexp">         root   html;</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">     # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line"><span class="regexp">     #</span></span><br><span class="line"><span class="regexp">     #location ~ \.php$ &#123;</span></span><br><span class="line"><span class="regexp">     #    proxy_pass   http:/</span><span class="regexp">/127.0.0.1;</span></span><br><span class="line"><span class="regexp">     #&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">     # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line"><span class="regexp">     #</span></span><br><span class="line"><span class="regexp">     #location ~ \.php$ &#123;</span></span><br><span class="line"><span class="regexp">     #    root           html;</span></span><br><span class="line"><span class="regexp">     #    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line"><span class="regexp">     #    fastcgi_index  index.php;</span></span><br><span class="line"><span class="regexp">     #    fastcgi_param  SCRIPT_FILENAME  /</span>scripts$fastcgi_script_name;</span><br><span class="line">     #    include        fastcgi_params;</span><br><span class="line">     #&#125;</span><br><span class="line"></span><br><span class="line">     # deny access to .htaccess files, if Apache's document root</span><br><span class="line">     # concurs with nginx's one</span><br><span class="line">     #</span><br><span class="line">     #location ~ /\.ht &#123;</span><br><span class="line">     #    deny  all;</span><br><span class="line">     #&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>   在上面的代码中,将<code>server_name</code>设置为你的域名,root设置为你的项目根目录.因为我将vumusic拷贝至html下面了,所以这样设置:<code>html/vuemusic;</code><br>   在上面代码中,哪里实现了代理转发呢？</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置代理转发</span><br><span class="line">location /api/ &#123;</span><br><span class="line">  proxy_pass  http://localhost:3000/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   意思就是说,在当前这个项目下,所有的<code>/api/</code>的请求,都会被代理至<code>http://localhost:3000/</code>下面.<br>   在nginx根目录下打开命令行窗口输入:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></p><p>   重新访问项目,就会发现,跨域问题成功解决.</p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Es6的学习笔记2</title>
      <link href="/2018/10/26/Es6%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <content type="html"><![CDATA[<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><p>   ES6对函数做了很多扩展.</p><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><p>   ES6允许为函数的参数设置默认值:<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">point</span> (<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span> y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> point();</span><br><span class="line">p&#123;<span class="attr">x</span>: <span class="comment">// 0 , y:  //0&#125;</span></span><br></pre></td></tr></table></figure></p>   <a id="more"></a><p>   但是在一般的情况下,定义了默认值的参数应该是函数的尾参数,如果非尾部的参数设置了默认值,实际上这个参数是无法省略的.</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x= <span class="number">1</span>,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x,y];</span><br><span class="line">&#125;</span><br><span class="line">f();  <span class="comment">//[1,undefined]</span></span><br><span class="line">f(<span class="number">2</span>);  <span class="comment">//[2,undefined]</span></span><br><span class="line">f( ,<span class="number">1</span>)  <span class="comment">//报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">//[1,1]</span></span><br></pre></td></tr></table></figure><h4 id="函数参数默认值的作用域"><a href="#函数参数默认值的作用域" class="headerlink" title="函数参数默认值的作用域"></a>函数参数默认值的作用域</h4><p>  一旦设置了参数的默认值,参数会形成一个单独的作用域,等到初始化完成之后,这个作用域才会消失.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x , y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span>)  <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><p>  在这个例子中,y 的默认值设置为等于x,形成了单独的作用域,于是y的值就和全局的x无关,调用f(2)的时候就将x的值赋给y.如图</p><p>  <img src="https://i.loli.net/2018/10/26/5bd2c811037d6.png" alt="寻找终点.png"></p><p>  另一个例子<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">f();  <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p>  那么在这个例子中,调用<code>f()</code>时,x初始化为<code>let x = 1</code>,所以形成单独的作用域,<code>y=x=1</code>,与里面的<code>let x = 2</code> 无关.如图</p><p>  <img src="https://i.loli.net/2018/10/26/5bd2c81103cad.png" alt="寻找终点 (1).png"></p><h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>  ES6引入了rest参数,形式为(“ <code>...变量名</code> “) ,用于获取函数多余的参数.</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>);   <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>  ES6规定只要函数的参数使用了默认值、解构赋值或者扩展运算符,那么函数的内部不允许设定为严格模式.</p><h4 id="函数的name属性"><a href="#函数的name属性" class="headerlink" title="函数的name属性"></a>函数的name属性</h4><p>  name属性会返回该函数的函数名.</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">f.name  <span class="comment">//"f"</span></span><br></pre></td></tr></table></figure><p>  匿名函数的name属性在ES5和ES6的区别如下:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">f.name  <span class="comment">// " "  ES5</span></span><br><span class="line">f.name  <span class="comment">// "f"  ES6</span></span><br></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>  ES6新增了箭头函数,形如<code>(=&gt;)</code>.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v; 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  如果箭头函数不需要参数或者需要多个参数,就使用圆括号代替参数部分.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>; 等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> num1+num2;   等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  如果箭头函数的代码块部分多于一条语句,就应该使用大括号将其括起来.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> &#123;<span class="keyword">return</span> num1+num2&#125;;</span><br></pre></td></tr></table></figure></p><p>  由于打括号被解释为一个代码块,所以如果箭头函数返回的是一个对象,就必须在对象外面加上括号.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem =  <span class="function"><span class="params">id</span> =&gt;</span> (&#123;</span><br><span class="line">  id : id,</span><br><span class="line">  name : <span class="string">"temp"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>  rest参数和箭头函数的结合.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line">numbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>)  <span class="comment">//[1,2,3,4,6]</span></span><br></pre></td></tr></table></figure></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head,...tail</span>) =&gt;</span> [head,tail];</span><br><span class="line">headAndTail(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);   <span class="comment">//[1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure><h4 id="箭头函数的注意事项"><a href="#箭头函数的注意事项" class="headerlink" title="箭头函数的注意事项"></a>箭头函数的注意事项</h4><p>  函数体内的<code>this</code>对象就是定义时所在的对象,而不是使用时所在的对象.<code>this</code>对象的指向是可变的,但在箭头函数中它是固定的.</p>]]></content>
      
      
        <tags>
            
            <tag> Es6 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Es6的学习笔记1</title>
      <link href="/2018/10/24/Es6%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <content type="html"><![CDATA[<h3 id="学习ES6的必要性"><a href="#学习ES6的必要性" class="headerlink" title="学习ES6的必要性"></a>学习ES6的必要性</h3><p>   前端的发展越来越快,因为其强大的扩展性、跨平台性,所以Es6标准就出来了.近来我一直在学习Es6,把这些笔记都记录下来.</p><h4 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h4><ul><li>let命令用来初始化变量,但是所声明的变量只在所属代码块有效.</li><li>不存在变量的提升(变量在声明之前使用，值为undefined).<a id="more"></a></li><li>let命令存在”暂时性死区”,只要块级作用域存在let命令，所声明的变量就”绑定”到这个区域,不受外部的影响.</li><li>let命令不允许重复声明.</li></ul><h4 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> t = f();</span><br><span class="line">   t * t + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  变量x会得到整个块级作用域的返回值.</p><h4 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h4><ul><li>const声明一个只读的常量,一旦初始化,就必须赋值.</li><li>const也只在对应的块级作用域有效.</li><li>const实际上保证的并不是变量的值不得改动,而是变量指向的那个内存地址不得改动,如下图:           </li></ul><p>  <img src="https://i.loli.net/2018/10/24/5bd02b27d6c28.png" alt="const" title="const"></p><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><p>  解构赋值:按照一定的模式从数组和对象中提取值,对变量进行赋值.此前为变量赋值只能直接指定值.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]   <span class="comment">// a = 1,b = 2, c = 3</span></span><br></pre></td></tr></table></figure></p><p>  这种写法属于”模式匹配”,只要等号两边的模式相同,左边的变量就会被赋予对应的值.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo,[[bar],baz]] = [<span class="number">1</span>,[[<span class="number">2</span>],<span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>  解构赋值可以设置默认值<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo =<span class="literal">true</span> ] = [];</span><br><span class="line">foo  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x,y = <span class="string">'b'</span>] = [<span class="string">'a'</span>];</span><br><span class="line"><span class="comment">// x = 'a'</span></span><br><span class="line"><span class="comment">// y = 'b'</span></span><br></pre></td></tr></table></figure><h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>  对象也可以进行解构赋值,但是对象的解构赋值与数组不同.数组的解构赋值直接按照次序来就可以了,但是对象的解构赋值必须与属性名同名,才能取到正确的值.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;far,foo&#125; = &#123;<span class="attr">foo</span>:<span class="string">"aaa"</span>,<span class="attr">bar</span>:<span class="string">"bbb"</span>&#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">far <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure></p><p>  下面来看一个反例<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;baz&#125; = &#123;<span class="attr">foo</span>:<span class="string">"aaa"</span>,<span class="attr">bar</span>:<span class="string">"bbb"</span>&#125;</span><br><span class="line"></span><br><span class="line">baz  <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">baz取不到正确的值</span><br></pre></td></tr></table></figure></p><p>  如果变量名与属性名不一致,可以写成这样<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>:baz &#125; = &#123; <span class="attr">foo</span>:<span class="string">"aaa"</span>,<span class="attr">bar</span>:<span class="string">"bbb"</span> &#125;</span><br><span class="line"></span><br><span class="line">baz  <span class="comment">//"aaa"</span></span><br></pre></td></tr></table></figure></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">"aaa"</span> , <span class="attr">last</span>: <span class="string">"bbb"</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">first</span> : f , <span class="attr">last</span> : l &#125;  = obj;</span><br><span class="line"></span><br><span class="line">f <span class="comment">// "aaa"</span></span><br><span class="line">l <span class="comment">//"bbb"</span></span><br></pre></td></tr></table></figure><p>  由此可见,对象的解构赋值的内部机制是先找到同名的属性,然后再赋值给对应的变量,真正被赋值的是后者,而不是前者.<br>  与数组一样,解构也可以用于嵌套的结构的对象.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: &#123;</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      y:<span class="string">'World'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>  &#123; <span class="attr">p</span> : &#123;x,&#123;y&#125; &#125; &#125; = obj;</span><br><span class="line"></span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure></p><h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x,y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>]);  <span class="comment">//3</span></span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>] ].map( <span class="function">(<span class="params">[a,b]</span>) =&gt;</span> a+b );</span><br><span class="line"><span class="comment">//[3,7]</span></span><br></pre></td></tr></table></figure><h4 id="解构赋值的好处"><a href="#解构赋值的好处" class="headerlink" title="解构赋值的好处"></a>解构赋值的好处</h4><ul><li>交换变量的值         </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x,y] = [y,x];</span><br></pre></td></tr></table></figure><p>  这样的语法在以前被认为是错误的,现在可行了</p><ul><li>从函数返回多个值     </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a,b,c] = example();</span><br><span class="line"><span class="comment">//返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo : <span class="number">1</span>,</span><br><span class="line">    bar : <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> &#123; foo , bar &#125; = example();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数参数的定义     </li></ul><p>  解构赋值可以很方便的将一组参数与变量名对应起来<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x,y,z]</span>)</span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line">传参数:</span><br><span class="line">f([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x,y,z&#125;</span>)</span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line">传参数:</span><br><span class="line">f(&#123;<span class="attr">z</span>:<span class="number">3</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">x</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>提取json数据     </p><p>这是带给我我最惊喜的功能了,简直方便不少啊!!</p><p>假如有一段json数据是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">   id : <span class="number">34</span>,</span><br><span class="line">   status : <span class="number">200</span>,</span><br><span class="line">   data:[<span class="number">45</span>,<span class="number">34</span>,<span class="number">32</span>]</span><br><span class="line">&#125;</span><br><span class="line">下面利用解构赋值来解析:</span><br><span class="line"> <span class="keyword">let</span> &#123; id , status , number &#125; = jsonData ;</span><br><span class="line"> <span class="built_in">console</span>.log(id , status , number);</span><br><span class="line"> <span class="comment">// 34 , 200 , [45,34,32]</span></span><br></pre></td></tr></table></figure><p>的确比以前用起来方便许多.</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue-cli 3.0请求本地模拟数据</title>
      <link href="/2018/10/11/Vue%20Cli3.0%E8%AF%B7%E6%B1%82%E6%9C%AC%E5%9C%B0%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE/"/>
      <content type="html"><![CDATA[<h3 id="升级的前后"><a href="#升级的前后" class="headerlink" title="升级的前后"></a>升级的前后</h3><p>  很多时候,我们在一个项目的开发阶段,需要用到本地的模拟数据.在3.0以前的版本,在项目的根目录下有一个webpack.dev.conf.js文件可以提供给开发者进行配置,但是现在升级之后,3.0的版本目录结构比以前精简很多,没有了这个文件,那么在这个版本我们怎么请求本地的模拟数据呢？<br>  <a id="more"></a></p><h3 id="请求本地模拟数据"><a href="#请求本地模拟数据" class="headerlink" title="请求本地模拟数据"></a>请求本地模拟数据</h3><ol><li>将模拟数据源文件放置到根目录下(data.json)   </li></ol><p>  <img src="http://wx2.sinaimg.cn/mw690/89296167gy1fw423ia7kej20xu0w00z6.jpg" alt="data.json" title="文件位置"></p><ol start="2"><li>在根目录下新建vue.config.js文件,并添加如下代码:    </li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line">  <span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>) <span class="comment">//引入express框架</span></span><br><span class="line">  <span class="keyword">const</span> app = express() <span class="comment">//实例化对象</span></span><br><span class="line">  <span class="keyword">var</span> appData = <span class="built_in">require</span>(<span class="string">'./data.json'</span>) <span class="comment">//引入存放数据的json</span></span><br><span class="line">  <span class="keyword">var</span> seller = appData.seller;<span class="comment">//取出数据</span></span><br><span class="line">  <span class="keyword">var</span> goods = appData.goods;</span><br><span class="line">  <span class="keyword">var</span> ratings = appData.ratings;</span><br><span class="line">  <span class="keyword">var</span> apiRoutes = express.Router(); <span class="comment">//引入路由</span></span><br><span class="line">  app.use(<span class="string">'/api'</span>,apiRoutes)</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 选项...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">    <span class="comment">//模拟数据开始</span></span><br><span class="line">        before(app) &#123;</span><br><span class="line">            app.get(<span class="string">'/api/seller'</span>, (req, res) =&gt; &#123;</span><br><span class="line">                res.json(&#123;</span><br><span class="line">                    <span class="comment">// 这里是你的json内容</span></span><br><span class="line">                    errno: <span class="number">0</span>,</span><br><span class="line">                    data: seller</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;),</span><br><span class="line">            app.get(<span class="string">'/api/goods'</span>, (req, res) =&gt; &#123;</span><br><span class="line">                res.json(&#123;</span><br><span class="line">                    <span class="comment">// 这里是你的json内容</span></span><br><span class="line">                    errno: <span class="number">0</span>,</span><br><span class="line">                    data: goods</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;),</span><br><span class="line">            app.get(<span class="string">'/api/ratings'</span>, (req, res) =&gt; &#123;</span><br><span class="line">                res.json(&#123;</span><br><span class="line">                    <span class="comment">// 这里是你的json内容</span></span><br><span class="line">                    errno: <span class="number">0</span>,</span><br><span class="line">                    data: ratings</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  从上面的代码可以看出,我们便可以通过’/api/seller’这个接口请求到本地的模拟数据</p><ol start="3"><li>取出数据         </li></ol><p>  在任意一个组件内,利用axios进行请求:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$axios.get(<span class="string">"/api/seller"</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  我们就可以拿到本地的模拟数据了:<br>  <img src="http://wx2.sinaimg.cn/mw690/89296167gy1fw41qkqekwj20uy0uqwlr.jpg" alt="data.json" title="文件位置"></p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue-cli 3.0解决跨域问题</title>
      <link href="/2018/10/08/Vue-cli%203.0%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h3 id="为什么要跨域？"><a href="#为什么要跨域？" class="headerlink" title="为什么要跨域？"></a>为什么要跨域？</h3><p>  Vue.js真的是一个很好的前端框架.它很好地实现了前后端分离.但是在前后端分离的项目中,一般都会涉及到跨域请求的问题,那么什么是跨域？跨域指浏览器不允许当前页面所在的源去请求另一个源的数据.源指的是协议、端口、域名.只要这3个中有一个不同的就是跨域.  <a id="more"></a></p><h3 id="Vue-cli-3-0怎么解决跨域问题？"><a href="#Vue-cli-3-0怎么解决跨域问题？" class="headerlink" title="Vue-cli 3.0怎么解决跨域问题？"></a>Vue-cli 3.0怎么解决跨域问题？</h3><p>  搞前端的朋友应该都知道,Vue官方在今年8月份左右更新了vue-cli(从2.0-&gt;3.0).脚手架的更新,使得vue项目的目录结构变得越来越简单,大量节省了程序员花在配置文件上的时间,在以前无法在项目初始化时自动初始化VueX,更新之后就可以了,甚至还支持Vue GUI,即是可以通过图形化界面新建Vue项目.那么说了这么多,我们到底怎么在3.0的版本上解决跨域问题呢？我去官网的文档上查看,官方文档至此还没完全翻译完全,以我这三脚猫的英语,实在难啃,不过还是解决了问题.<br>  在项目根目录创建vue.config.js文件,然后到这个文件添加:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">  baseUrl: <span class="string">'/'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">        port: <span class="number">8080</span>, <span class="comment">// 端口号</span></span><br><span class="line">        host: <span class="string">'localhost'</span>,</span><br><span class="line">        https: <span class="literal">false</span>, <span class="comment">// https:&#123;type:Boolean&#125;</span></span><br><span class="line">        open: <span class="literal">true</span>, <span class="comment">//配置自动启动浏览器</span></span><br><span class="line">        <span class="comment">// proxy: 'http://localhost:4000' // 配置跨域处理,只有一个代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'url'</span>,<span class="comment">//后端接口地址</span></span><br><span class="line">                ws: <span class="literal">true</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span><span class="comment">//是否允许跨域</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// 配置多个代理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  有了这段代码可刺激了,你就可以实现跨域请求到后台数据:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v.$axios.post(<span class="string">'/api/index'</span>, &#123;</span><br><span class="line"></span><br><span class="line">   &#125;,&#123;</span><br><span class="line"></span><br><span class="line">   &#125;).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(response.data.meta.code===<span class="number">200</span>)&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(response.data);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       alert(<span class="string">'系统异常'</span>)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></p><p>  你就可以跨域项目源地址,到后台接口调数据,从而实现跨域.</p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tomcat配置域名访问</title>
      <link href="/2018/10/03/Tomcat%E7%9A%84%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE/"/>
      <content type="html"><![CDATA[<h3 id="Tomcat基本配置"><a href="#Tomcat基本配置" class="headerlink" title="Tomcat基本配置"></a>Tomcat基本配置</h3><p>  我们在构建一个网站的时候,常常选择Tomcat作为服务器的工程项目容器.所以我们需要将域名配置到Tomcat上,也就是说我们可以通过域名直接访问我们的网站.<br>  <a id="more"></a><br>  先将你的项目打包上传至服务器.然后放置到Tomcat目录下的webapps下.<br>  <img src="http://wx1.sinaimg.cn/mw690/89296167gy1fvvasnv5rwj211w0hwn05.jpg" alt="文件"></p><p>  然后进入conf目录下,打开server.xml进行编辑.<br>  配置域名能直接访问项目,需要在server.xml添加以下代码：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  &lt;Host name=&quot;www.xieyezi.com&quot;  appBase=&quot;webapps&quot;</span><br><span class="line">      unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</span><br><span class="line">      &lt;Context docBase=&quot;C:\Program Files\apache-tomcat-9.0.7-windows-x64\apache-tomcat-9.0.7\webapps\Xydesign&quot; path=&quot;&quot; reloadable=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;!-- SingleSignOn valve, share authentication between web applications</span><br><span class="line">       Documentation at: /docs/config/valve.html --&gt;</span><br><span class="line">  &lt;!--</span><br><span class="line">  &lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt;</span><br><span class="line">  --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Access log processes all example.</span><br><span class="line">       Documentation at: /docs/config/valve.html</span><br><span class="line">       Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt;</span><br><span class="line">  &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</span><br><span class="line">         prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</span><br><span class="line">         pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure></p><ol><li>配置项目通过域名访问    </li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Host name=&quot;www.xieyezi.com&quot;  appBase=&quot;hcode&quot;</span><br><span class="line">          unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure><p>  将Host标签的name设置为你的域名,appBase设置为你的项目的路径(可以为绝对路径和相对路径,你可以看见我这里设置为相对路径).<br>  配置完成即可保存,然后通过 <a href="http://www.xieyezi.com/Xydesign" target="_blank" rel="noopener">http://www.xieyezi.com/Xydesign</a> 访问.</p><ol start="2"><li>配置项目名缺省进行访问     </li></ol><p>  一般的,我们一般是直接访问域名就进行访问.而不是通过在域名末尾添加项目名进行访问.<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context docBase=&quot;hcode&quot; path=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>  其中,docBase即为项目的绝对路径,此时通过 <a href="http://www.xieyezi.com" target="_blank" rel="noopener">http://www.xieyezi.com</a> 即可进行项目名缺省的访问.</p><ol start="3"><li>部署多个项目到Tomcat     </li></ol><p>  将你的项目打包放置到webapps路径下,然后在server.xml的Host下面添加以下代码:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context path=&quot;&quot; docBase=&quot;&quot; debug=&quot;0&quot; reloadable=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>  将path标签设置为<code>/你的项目名</code>,docBase设置为<code>你的项目根目录的绝对路径</code>.<br>  配置完成即可保存,然后通过 <a href="http://www.xieyezi.com/项目名" target="_blank" rel="noopener">http://www.xieyezi.com/项目名</a> 访问.</p><ol start="4"><li>https访问配置    </li></ol><p>  在server.xml添加以下代码:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">             maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;</span><br><span class="line">             clientAuth=&quot;false&quot;</span><br><span class="line">              sslProtocol=&quot;TLS&quot;</span><br><span class="line">              keystoreFile=&quot;/home/doc/keys/213972284410468.pfx&quot;</span><br><span class="line">              keystoreType=&quot;PKCS12&quot;</span><br><span class="line">              keystorePass=&quot;213972284410468&quot;         /&gt;</span><br></pre></td></tr></table></figure></p><p>  添加keystoreFile,keystoreType,keystorePass即可进行https访问.</p><ol start="5"><li>自动跳转到https连接    </li></ol><p>  如果希望输入http链接时自动跳转到https,需要在web.xml中添加如下内容:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;login-config&gt;</span><br><span class="line">              &lt;!-- Authorization setting for SSL --&gt;</span><br><span class="line">              &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt;</span><br><span class="line">                      &lt;realm-name&gt;Client Cert Users-only Area&lt;/realm-name&gt;</span><br><span class="line">      &lt;/login-config&gt;</span><br><span class="line">      &lt;security-constraint&gt;</span><br><span class="line">              &lt;!-- Authorization setting for SSL --&gt;</span><br><span class="line">              &lt;web-resource-collection &gt;</span><br><span class="line">                      &lt;web-resource-name &gt;SSL&lt;/web-resource-name&gt;</span><br><span class="line">                      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">              &lt;/web-resource-collection&gt;</span><br><span class="line">              &lt;user-data-constraint&gt;</span><br><span class="line">                      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;</span><br><span class="line">              &lt;/user-data-constraint&gt;</span><br><span class="line">      &lt;/security-constraint&gt;</span><br></pre></td></tr></table></figure></p><p>  以上内容位置在<code>&lt;/web-app&gt;</code>内,添加后输入http访问时会自动跳转到https连接.</p>]]></content>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css超出部分显示省略号</title>
      <link href="/2018/09/28/css%E8%B6%85%E5%87%BA%E9%83%A8%E5%88%86%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/"/>
      <content type="html"><![CDATA[<h3 id="超出部分显示为省略号"><a href="#超出部分显示为省略号" class="headerlink" title="超出部分显示为省略号"></a>超出部分显示为省略号</h3><p>  我们经常遇见要展示一行或者多行内容，超出部分会让我们的页面变得很难看，所以我们需要设置一下超出部分显示省略号。</p><ul><li>内容为一行   </li></ul>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden;//把超出的内容进行隐藏</span><br><span class="line"><span class="selector-tag">text-overflow</span><span class="selector-pseudo">:ellipsis</span>;设置超出内容为省略号</span><br><span class="line">white-space: nowrap;//设置内容不换行</span><br></pre></td></tr></table></figure>  <a id="more"></a><ul><li>内容为两行     </li></ul>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 3;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><p>  其实原理很简单，主要是针对行内元素进行限制，如果超过了一行的宽度，则显示为省略号，所以你也可以自己设定宽度:<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span><span class="selector-pseudo">:500px</span>;</span><br></pre></td></tr></table></figure></p><h3 id="块级元素与行内元素"><a href="#块级元素与行内元素" class="headerlink" title="块级元素与行内元素"></a>块级元素与行内元素</h3><p>  我们知道，HTML分为块级元素和行内元素，其中</p><ul><li>块级元素有：body  from  select  textarea  h1-h6 html table  button  hr  p  ol  ul  dl  cnter  div</li><li>行内元素有：heda   meat   title  lable  span  br  a   style  em  b  i   strong       </li></ul><p>  块级元素和行内元素的主要区别是行内元素书写完成后不会自动换行，并且元素没有宽和高。块级元素写完后会自动换行，有宽高可以修改。<br>  那我们如何将块级元素转化为行内元素呢？<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>：<span class="selector-tag">inline-block</span></span><br></pre></td></tr></table></figure></p><p>  那如何将行内元素转化为块级元素呢？<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>：<span class="selector-tag">block</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端知识小记</title>
      <link href="/2018/09/28/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  最近接手了公司的一个项目,因为刚来公司,所以对公司的业务内容不够熟悉,做起来实在是很累.其实说白了就是自己的功力不够.很多不了解我的人都认为我很厉害,其实我什么都不会(emmmm).所以才应该从现在开始才应该多多积累,有什么小的东西就应该记录下来.有一句话说得很不错：每一天的小努力*365=巨大的飞跃！<br>  <a id="more"></a></p><h3 id="css如何设置div滚动显示？"><a href="#css如何设置div滚动显示？" class="headerlink" title="css如何设置div滚动显示？"></a>css如何设置div滚动显示？</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min-height:250px;</span><br><span class="line">overflow-y:auto;</span><br><span class="line">max-height:300px;</span><br></pre></td></tr></table></figure><p>  例如<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"滚动显示的区域"</span> <span class="attr">style</span>=<span class="string">"min-height:250px;overflow-y:auto;max-height:300px;"</span>&gt;</span></span><br><span class="line">    😂😂😂</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  上面的例子很简单,其实最主要的属性设置是”overflow-y:auto”,其余两条css样式其实就是设置了子div的高度,如果只设置这一条属性的话,滚动的区域就是父div的g高度,意思是,一旦你滑动屏幕,超出了父div的高度,你的子div就会出现滚动条,从而实现滚动显示.</p><h3 id="Vue组件库iView的使用"><a href="#Vue组件库iView的使用" class="headerlink" title="Vue组件库iView的使用"></a>Vue组件库iView的使用</h3><p>   同学们,我个人强烈安利这个组件库,按照官网的说法来说,<a href="https://www.iviewui.com/docs/guide/introduce" target="_blank" rel="noopener">iView</a> 是一套基于 Vue.js 的开源 UI 组件库,主要服务于 PC 界面的中后台产品.可能熟悉Vue的朋友们都知道饿了么组件库（<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">Element</a>）,其实就我来看,其实饿了么组件库相对于iView过于繁琐,为什么这么说呢？因为饿了么总是会写很多内联样式,这对于我们后期的维护和优化来说简直是个巨大的工程,无异于重写界面;其次,要知道,Vue的核心思想就是组件化,一个单页面应该具有独立的样式,饿了么这样的做法简直天理难容😂.而iView组件库则很好的优化了这一方面,而且这个组件库更加Vue.（ps：我曾经听过一个笑话,说A同学帮B同学看代码,最后得出了结论,A同学认为B同学写的代码一点也不Vue…..）.另外,因为它比较方便,所以对开发者的要求变高了,要想基本使用,需要基本了解以下知识：</p><ul><li>Vue组件</li><li>单文件组件</li><li>props 传递数据</li><li>slot 内容分发</li><li>events $emit @click 事件      </li></ul><p>   我也只是初步学习阶段,说了这么多,我来简单说一下,这个组件库的用法.</p><ol><li>安装         </li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install iview --save</span><br></pre></td></tr></table></figure><p>   不知道同学们至今为止,有没有把node、npm、webpack、Vue-cli安装好,如果没有,那赶紧去！</p><ol start="2"><li>引用      </li></ol><p>   在项目的入口文件main.js下<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> iView <span class="keyword">from</span> <span class="string">'iview'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'iview/dist/styles/iview.css'</span>;</span><br><span class="line">Vue.use(iView);</span><br></pre></td></tr></table></figure></p><p>   然后其组件的使用自己去看官方文档</p><h3 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h3><p>  现在是北京时间9月28日凌晨00:20,在乏累中写完这篇文章,和大家分享学习.祝大家晚安,明天又将是精彩的一天!</p>]]></content>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue组件库iView的使用</title>
      <link href="/2018/09/28/Vue%E7%BB%84%E4%BB%B6%E5%BA%93iView%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  最近接手了公司的一个项目,因为刚来公司,所以对公司的业务内容不够熟悉,做起来实在是很累.其实说白了就是自己的功力不够.很多不了解我的人都认为我很厉害,其实我什么都不会(emmmm).所以才应该从现在开始才应该多多积累,有什么小的东西就应该记录下来.有一句话说得很不错：每一天的小努力*365=巨大的飞跃！<br>  <a id="more"></a></p><h3 id="css如何设置div滚动显示？"><a href="#css如何设置div滚动显示？" class="headerlink" title="css如何设置div滚动显示？"></a>css如何设置div滚动显示？</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min-height:250px;</span><br><span class="line">overflow-y:auto;</span><br><span class="line">max-height:300px;</span><br></pre></td></tr></table></figure><p>  例如<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"滚动显示的区域"</span> <span class="attr">style</span>=<span class="string">"min-height:250px;overflow-y:auto;max-height:300px;"</span>&gt;</span></span><br><span class="line">    😂😂😂</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  上面的例子很简单,其实最主要的属性设置是”overflow-y:auto”,其余两条css样式其实就是设置了子div的高度,如果只设置这一条属性的话,滚动的区域就是父div的g高度,意思是,一旦你滑动屏幕,超出了父div的高度,你的子div就会出现滚动条,从而实现滚动显示.</p><h3 id="Vue组件库iView的使用"><a href="#Vue组件库iView的使用" class="headerlink" title="Vue组件库iView的使用"></a>Vue组件库iView的使用</h3><p>   同学们,我个人强烈安利这个组件库,按照官网的说法来说,<a href="https://www.iviewui.com/docs/guide/introduce" target="_blank" rel="noopener">iView</a> 是一套基于 Vue.js 的开源 UI 组件库,主要服务于 PC 界面的中后台产品.可能熟悉Vue的朋友们都知道饿了么组件库（<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">Element</a>）,其实就我来看,其实饿了么组件库相对于iView过于繁琐,为什么这么说呢？因为饿了么总是会写很多内联样式,这对于我们后期的维护和优化来说简直是个巨大的工程,无异于重写界面;其次,要知道,Vue的核心思想就是组件化,一个单页面应该具有独立的样式,饿了么这样的做法简直天理难容😂.而iView组件库则很好的优化了这一方面,而且这个组件库更加Vue.（ps：我曾经听过一个笑话,说A同学帮B同学看代码,最后得出了结论,A同学认为B同学写的代码一点也不Vue…..）.另外,因为它比较方便,所以对开发者的要求变高了,要想基本使用,需要基本了解以下知识：</p><ul><li>Vue组件</li><li>单文件组件</li><li>props 传递数据</li><li>slot 内容分发</li><li>events $emit @click 事件      </li></ul><p>   我也只是初步学习阶段,说了这么多,我来简单说一下,这个组件库的用法.</p><ol><li>安装         </li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install iview --save</span><br></pre></td></tr></table></figure><p>   不知道同学们至今为止,有没有把node、npm、webpack、Vue-cli安装好,如果没有,那赶紧去！</p><ol start="2"><li>引用      </li></ol><p>   在项目的入口文件main.js下<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> iView <span class="keyword">from</span> <span class="string">'iview'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'iview/dist/styles/iview.css'</span>;</span><br><span class="line">Vue.use(iView);</span><br></pre></td></tr></table></figure></p><p>   然后其组件的使用自己去看官方文档</p><h3 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h3><p>  现在是北京时间9月28日凌晨00:20,在乏累中写完这篇文章,和大家分享学习.祝大家晚安,明天又将是精彩的一天!</p>]]></content>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue开发环境的搭建</title>
      <link href="/2018/09/26/%E6%90%AD%E5%BB%BAVue%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  学了Vue也算是有段时间了,我看了一下自己的博客记录,居然没有一篇写如何搭建Vue开发环境的,于是才有了这篇博文.现在前端的开发更趋向于工程化、模块化,所以使用Vue-Cli是非常必要的.基本来说,要将Vue项目跑起来,要用到以下工具:</p><ul><li>Node.js</li><li>npm</li><li>webpack</li><li>Vue-Cli    <a id="more"></a></li></ul><p>  其中我说一下Vue-Cli.Vue-Cli称为脚手架,其实说白了就是命令行工具,通过这个工具,你可以在命令行初始化工程项目,帮你迅速搭好工程框架.下面来说说到底如何搭建Vue开发环境并运行你的第一个Vue项目吧.</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>     </li></ol><p>  到官网去下载相应到版本,然后一路点击下一步迅速安装好</p><ol start="2"><li>查看是否安装成功       </li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>  如果出现版本号,说明安装成功<br>  注：如果是Mac,记得输入以下命令更改Node.js目录的访问权限<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R 777 /usr/local/lib/node_modules/</span><br></pre></td></tr></table></figure></p><ol start="3"><li>新建工程目录       </li></ol><p>  在你的电脑任何你喜欢的位置新建一个文件夹<br>  启动你的命令行进入你刚刚新建的文件夹目录下</p><ol start="4"><li>全局安装npm       </li></ol><p>  能翻墙的同学请打开翻墙执行以下命令进行安装<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm</span><br></pre></td></tr></table></figure></p><p>  不能翻墙的同学也没关系,请使用以下命令进行安装<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>  在这里,我们使用了淘宝镜像进行安装,记住,以后所有以npm开头的命令,不能翻墙的同学都要以cnpm代替</p><ol start="5"><li>全局安装webpack       </li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack -g</span><br></pre></td></tr></table></figure><p>  同学你记住我刚刚说的话没有,如果你不能翻墙,请把上面👆这条命令的npm 换成cnpm</p><ol start="6"><li>全局安装Vue-Cli脚手架        </li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure><p>  完成了上面的6步,恭喜你,现在可以搭建项目了.</p><ol start="7"><li>搭建项目         </li></ol><p>  在你的电脑里面随便一个你喜欢的位置,新建一个文件夹</p><ol start="8"><li>打开命令行,进入到你刚刚创建的文件夹目录下         </li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack projectName(&quot;项目的名字,不能使用中文哦&quot;)</span><br></pre></td></tr></table></figure><p>  接着会有一些基础的配置信息需要你填,记住,需要你选择(y/n)的,你现在都先选择n.<br>  完成了这一步,你就可以在你刚刚新建的文件夹里面看见新建的项目了.</p><ol start="9"><li>安装依赖包         </li></ol><p>  现在利用命令行进入到你的项目文件夹根目录下<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><ol start="10"><li>跑起来          </li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>  Vue一般是走8080端口,打开你的浏览器,进入locallhost://8080,就可以看见你的第一个Vue项目运行起来了.</p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gulp的基本使用</title>
      <link href="/2018/09/24/Gulp%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <content type="html"><![CDATA[<h3 id="Gulp是什么"><a href="#Gulp是什么" class="headerlink" title="Gulp是什么?"></a>Gulp是什么?</h3><p>  Gulp 是基于node.js的一个前端自动化构建工具,开发这可以使用它构建自动化工作流程（前端集成开发环境）. 使用gulp你可以简化工作量,让你把重点放在功能的开发上,从而提高你的开发效率和工作质量.说简单点，gulp和webpack一样,都是基于Node.js的前端工程化打包工具.所以在使用之前，必须安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>.<br>  <a id="more"></a></p><h3 id="如何使用Gulp？"><a href="#如何使用Gulp？" class="headerlink" title="如何使用Gulp？"></a>如何使用Gulp？</h3><p>  全局安装<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp -g</span><br></pre></td></tr></table></figure></p><p>  查看是否安装成功<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp -v</span><br></pre></td></tr></table></figure></p><p>  打开命令行,进入项目根路径<br>  初始化项目<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p><p>  为项目安装gulp依赖包<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp --save-dev</span><br></pre></td></tr></table></figure></p><p>  执行gulp(运行项目)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure></p><h3 id="近来情况的总结"><a href="#近来情况的总结" class="headerlink" title="近来情况的总结"></a>近来情况的总结</h3><p>  9月中旬来到了上海.来上海的目的十分简单,我想要在明年毕业之前变成一个厉害的人.所以才有了独自一个人来上海学习、生活的勇气.近来好像成长了很多,以前总是会因为这样或者那样的事情困扰不已,现在慢慢的看淡一些事情,结果发现事情好像反而变简单了一些.接下来的日子里,要踏踏实实静下心来学习,无论是技术,还是生活.今天是中秋节,祝自己中秋节快乐,明天又将是精彩的一天!</p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
            <tag> Gulp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VueX的相关使用</title>
      <link href="/2018/09/03/VueX%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/"/>
      <content type="html"><![CDATA[<h3 id="VueX是什么"><a href="#VueX是什么" class="headerlink" title="VueX是什么?"></a>VueX是什么?</h3><p>  Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式.它采用集中式存储管理应用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化.Vuex 也集成到 Vue 的官方调试工具 devtools extension,提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能.<br>  <a id="more"></a><br>  总的来说,我们对一个单向的数据流的操作如下图:<br>  <img src="http://wx4.sinaimg.cn/mw690/89296167gy1fuwd8r9apvj20zk0o2gm0.jpg" alt="flow"></p><p>  我们在视图(view)上对数据进行了类似于点击等操作,就会通过Action触发对数据的状态(State)的改变,就形成了这样的单向数据流操作.</p><h3 id="为什么要用VueX？"><a href="#为什么要用VueX？" class="headerlink" title="为什么要用VueX？"></a>为什么要用VueX？</h3><p>  许多组件需要同时共享一个数据的使用和更新,但是组件之间无法全然构成子父级组件的关系,此时针对这个数据就需要一个公共的状态管理器,也就是VueX.所以当项目组件与组件之间存在着太复杂的共享关系和操作时,就应该使用VueX.</p><h3 id="VueX的核心"><a href="#VueX的核心" class="headerlink" title="VueX的核心"></a>VueX的核心</h3><p>  每一个 Vuex 应用的核心就是 store（仓库）.“store”基本上就是一个容器,它包含着你的应用中大部分的状态 (state).Vuex 和单纯的全局对象有以下两点不同:</p><ol><li><p>Vuex 的状态存储是响应式的.当 Vue 组件从 store 中读取状态的时候,若 store 中的状态发生变化,那么相应的组件也会相应地得到高效更新.</p></li><li><p>你不能直接改变 store 中的状态.改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation.这样使得我们可以方便地跟踪每一个状态的变化,从而让我们能够实现一些工具帮助我们更好地了解我们的应用.      </p></li></ol><p>   VueX其实就是为上图的三个操作增加了流程,如下图:<br>   <img src="http://wx2.sinaimg.cn/mw690/89296167gy1fuwdllhvgoj20jh0fbwef.jpg" alt="VueX"></p><p>   VueX增加了Mutation.在这里,将操作(Action)统一提交到Mutation,在Mutation经过一系列的处理,再改变(状态)State,状态改变之后,再反应到视图(view)上.<br>   就像下面这样:<br>   <img src="http://wx1.sinaimg.cn/mw690/89296167gy1fuwdzb7lvbj20q903fglk.jpg" alt="VueX流程图"><br>   所以VueX就很好理解了.就是统一管理公共状态的东西.<br>   不过需要注意一点:<br>   Action不是必需的操作,如果有异步操作时才用到Action,否则可以不使用.也就是说,View可以直接提交到Mutation,从而改变状态,引起视图的改变.<br>   Action 类似于 mutation,不同在于:</p><ul><li>Action 提交的是 mutation,而不是直接变更状态.</li><li>Action 可以包含任意异步操作.      </li></ul><h3 id="核心概念和使用"><a href="#核心概念和使用" class="headerlink" title="核心概念和使用"></a>核心概念和使用</h3><ol><li>核心概念</li></ol><ul><li>State</li><li>Getter</li><li>Mutation</li><li>Action         </li></ul><ol start="2"><li>VueX的基本使用         </li></ol><p>  安装(npm):<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure></p><p>  引入:<br>  在项目src文件夹下新建store文件夹,再到store文件夹新建index.js文件:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">//创建一个store仓库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    count: <span class="number">11</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>  注:目前vue官方没有关于vuex的脚手架工具,所以必须手动store文件夹和index.js文件.<br>  在main.js导入:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br></pre></td></tr></table></figure></p><p>  新建State(在index.js文件)<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state:&#123;</span><br><span class="line">  count: <span class="number">11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  在外部组件中获取count的值:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> computed:&#123;</span><br><span class="line">  getCount()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的this.$store.state.count即是通过State获取</span></span><br></pre></td></tr></table></figure></p><p>  不过一般都会为state添加Getter:Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）.就像计算属性一样,getter 的返回值会根据它的依赖被缓存起来,且只有当它的依赖值发生了改变才会被重新计算.<br>  在这里我们为count新建一个getter(在index.js):<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">  getState(state)&#123;</span><br><span class="line">    <span class="keyword">return</span> state.count &gt; <span class="number">0</span> ? state.count : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  所以在组件中获取count值的方法要通过getter:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> computed:&#123;</span><br><span class="line">  getCount()&#123;</span><br><span class="line">    <span class="comment">// return this.$store.state.count;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.getState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的this.$store.getters.getState即是通过getter获取</span></span><br></pre></td></tr></table></figure></p><p>  状态(State)和getter建好以后,我们先通过mutations改变count的值:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">  incres(state)&#123;</span><br><span class="line">    state.count++;</span><br><span class="line">  &#125;,</span><br><span class="line">  decre(state)&#123;</span><br><span class="line">    state.count--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的incres函数即为count作++操作,decre函数为count作--操作</span></span><br></pre></td></tr></table></figure></p><p>  在外部组件中使用:<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>加加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里为template里面的内容 --&gt;</span></span><br></pre></td></tr></table></figure></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  add()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">"incres"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这里通过commit调用了incres函数</span></span><br></pre></td></tr></table></figure><p>  以上就是通过mutations改变count的值,接下来我们通过actions来改变count的值:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// context 承上启下,在这里可以通过context调用到commit的执行</span></span><br><span class="line">  incres(context)&#123;</span><br><span class="line">    context.commit(<span class="string">"incres"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  decre(context)&#123;</span><br><span class="line">    context.commit(<span class="string">"decre"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  在外部组件中使用:<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"min"</span>&gt;</span>减减<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里为template里面的内容 --&gt;</span></span><br></pre></td></tr></table></figure></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  min()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">"decre"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这里通过dispatch调用了decre函数</span></span><br></pre></td></tr></table></figure><p>  以上就是通过actions改变count的值.<br>  总结:mutation 像事件注册,需要相应的触发条件.而 Action 就是那个管理触发条件的.mutations只能同步执行,actions则可以执行异步操作.</p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>路由的基本加载</title>
      <link href="/2018/09/02/Vue%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%A0%E8%BD%BD/"/>
      <content type="html"><![CDATA[<h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><p>  Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果<a id="more"></a></li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为     </li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>  1.安装<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure></p><p>  2.引用<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &apos;vue-router&apos;</span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></p><p>  3.配置路由文件(新建router文件夹,新建index.js文件)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueRouter from &quot;vue-router&quot;</span><br><span class="line">import HelloWorld from &apos;../components/HelloWorld&apos;</span><br><span class="line">import Xie from &apos;../components/xieyezi&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;</span><br><span class="line">      path:&quot;/&quot;,</span><br><span class="line">      component:HelloWorld</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&quot;/xieyezi&quot;,</span><br><span class="line">      component:Xie</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>  4.注册路由(在main.js中注册)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  router,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">此处的router即为注册了路由</span><br></pre></td></tr></table></figure></p><p>  5.跳转(导航)<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"urlData.HelloWorld"</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"urlData.xieyezi"</span>&gt;</span>xieyezi<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue使用axios的get和post请求</title>
      <link href="/2018/08/30/Vue%E4%BD%BF%E7%94%A8axios%E7%9A%84get%E5%92%8Cpost%E8%AF%B7%E6%B1%82/"/>
      <content type="html"><![CDATA[<h3 id="安装axios"><a href="#安装axios" class="headerlink" title="安装axios"></a>安装axios</h3><p>  <a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">Axios</a> 是一个基于 promise 的 HTTP 库,可以用在浏览器和 node.js 中.</p><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API<a id="more"></a></li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF        </li></ul><p>  我觉得在自动转换json数据这一点上深得我心.haha<br>  在vue.js中使用它之前须安装(这里只介绍npm安装):<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure></p><h3 id="在vue项目中引入"><a href="#在vue项目中引入" class="headerlink" title="在vue项目中引入"></a>在vue项目中引入</h3><p>  在vue项目中找到main.js,先引入:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br></pre></td></tr></table></figure></p><p>  再将其绑定到vue实例的原型对象上:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure></p><h3 id="在组件中执行get请求"><a href="#在组件中执行get请求" class="headerlink" title="在组件中执行get请求"></a>在组件中执行get请求</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">  this.$http.get(&quot;https://zhihu-daily.leanapp.cn/api/v1/last-stories&quot;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    this.newsData = res.data.STORIES.stories;</span><br><span class="line">    // console.log(res.data.STORIES.stories);</span><br><span class="line">    console.log(this.newsData);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这里请求知乎日报接口,将接收的数据存放在名为newsData的数组里面<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line"> return &#123;</span><br><span class="line">   newsData:[]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>  应用数据展示在前端页面<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"news of newsData"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; news.title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"news.images[0]"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="在组件中执行post请求"><a href="#在组件中执行post请求" class="headerlink" title="在组件中执行post请求"></a>在组件中执行post请求</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">  this.$http.post(&quot;https://www.apiopen.top/journalismApi&quot;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    this.news = res.data;</span><br><span class="line">    console.log(this.news.data.auto);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这里将接收的数据赋值给名为news的对象<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    news:&apos;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>  应用数据展示在前端页面<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">lang</span>=<span class="string">"html"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in news.data.auto"</span>&gt;</span></span><br><span class="line">         &#123;&#123; item.title &#125;&#125;</span><br><span class="line">         <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"item.picInfo[0].url"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac安装Vue.js devtools插件无法使用的解决方法</title>
      <link href="/2018/08/24/Mac%E5%AE%89%E8%A3%85Vue.js%20devtools%E6%8F%92%E4%BB%B6%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <content type="html"><![CDATA[<h3 id="Mac安装Vue-js-devtools插件无法使用？"><a href="#Mac安装Vue-js-devtools插件无法使用？" class="headerlink" title="Mac安装Vue.js devtools插件无法使用？"></a>Mac安装Vue.js devtools插件无法使用？</h3><p>  在Mac os的谷歌浏览器里面安装插件<a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener">vue.js devtools</a>之后,发现启动vue项目之后,我们无法使用的情况：<br>  <a id="more"></a><br>  <img src="http://wx4.sinaimg.cn/mw690/89296167gy1fukn6l5256j21kw0zk7j1.jpg" alt="无法使用"></p><p>  可以有如下解决方法：<br>  在Mac finder前往Chrome安装插件的文件夹：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Application Support/Google/Chrome/Default/Extensions</span><br></pre></td></tr></table></figure></p><p>  找到devtools的安装文件夹：<br>  <img src="http://wx4.sinaimg.cn/mw690/89296167gy1fuknal6mp8j216s0o80z1.jpg" alt="文件夹位置"></p><p>  打开此文件夹里面的manifest.json文件,作出如下修改：<br>  <img src="http://wx1.sinaimg.cn/mw690/89296167gy1fuknf0zp93j21kw0vudtb.jpg" alt="修改"></p><p>  然后重启vue项目,进入到Chrome里面,就可以正常使用了.<br>  <img src="http://wx4.sinaimg.cn/mw690/89296167gy1fuknh431mgj21kw0zkh0l.jpg" alt="正常使用"></p>]]></content>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Chrome </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue过渡与动画</title>
      <link href="/2018/08/22/Vue%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
      <content type="html"><![CDATA[<h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><p>  Vue 在插入、更新或者移除 DOM 时,提供多种不同方式的应用过渡效果.<br>  包括以下工具：</p><ul><li>在 CSS 过渡和动画中自动应用 class</li><li>可以配合使用第三方 CSS 动画库，如 Animate.css<a id="more"></a></li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li><li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js    </li></ul><p>  注： 后面两种工具涉及到太多js的操作，一般来说很消耗内存，故不太多使用.    </p><h3 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h3><p>  Vue封装了transition的封装组件,可以为任何元素和组件添加进入/离开过渡</p><ul><li>条件渲染(v-if)</li><li>条件展示(v-show)</li><li>动态组件</li><li>组件根节点     </li></ul><p>  使用方法：<br>  template部分：<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">lang</span>=<span class="string">"html"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">"button"</span> <span class="attr">v-on:click</span>=<span class="string">"showHide"</span>&gt;</span>过渡<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  script部分：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"anim"</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        show:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      showHide()&#123;</span><br><span class="line">        <span class="keyword">this</span>.show=!<span class="keyword">this</span>.show;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>  style部分：<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fade-enter</span>&#123;</span><br><span class="line"><span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter-active</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter-to</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-leave-enter</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-leave-active</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-leave-to</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  总结：将元素放置在transition标签下,为transition标签赋值一个name属性,然后在样式表里面实现动画.<br>  形如：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=<span class="string">"my transition"</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>  当插入或删除包含在 transition 组件中的元素时,Vue 将会自动嗅探目标元素是否应用了 CSS 过渡或动画,如果是,在恰当的时机添加/删除 CSS 类名.<br>  在进入/离开的过渡中,有6个class切换：</p><ul><li>v-enter:定义进入过渡的开始状态</li><li>v-enter-active:执行过程中</li><li>v-enter-to:结束动画</li><li>v-leave:定义离开过渡的开始状态</li><li>v-leave-active:离开过程</li><li>v-leave-to:离开结束     </li></ul><p>  <img src="http://wx4.sinaimg.cn/mw690/89296167gy1fujeqr2duhj20xc0godfv.jpg" alt="过渡" title="过渡"></p><p>  过渡总共有6个状态,进入有3个,退出有3个.<br>  在使用时6个都应使用,形如：<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fade-enter</span>&#123;</span><br><span class="line"><span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter-active</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter-to</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-leave-enter</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-leave-active</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-leave-to</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h3><p>  CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。<br>  在使用动画时,通常只需要控制enter-active和leave-active两个过程即可.<br>  例如：<br>  template部分：<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">lang</span>=<span class="string">"html"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">"button"</span> <span class="attr">v-on:click</span>=<span class="string">"showHideAnim"</span>&gt;</span>动画<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"showAnim"</span>&gt;</span>嘿嘿<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  script部分：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"anim"</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        show:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      showHideAnim()&#123;</span><br><span class="line">        <span class="keyword">this</span>.showAnim=!<span class="keyword">this</span>.showAnim;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>  style部分：<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hello-enter-active</span>&#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in <span class="number">1s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hello-leave-active</span>&#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in <span class="number">1s</span> ease reverse;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> bounce-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(0);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(1.5);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="引入第三方css动画库"><a href="#引入第三方css动画库" class="headerlink" title="引入第三方css动画库"></a>引入第三方css动画库</h3><p>  可以在index.html引入外部css动画库,如<a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener">Animate</a>.<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/animate.css@3.5.1"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>  然后在组件中可以直接使用：<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"custom-classes-transition"</span> <span class="attr">enter-active-class</span>=<span class="string">"animated tada"</span> <span class="attr">leave-active-class</span>=<span class="string">"animated bounceOutRight"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"libs"</span>&gt;</span>呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue插槽与缓存</title>
      <link href="/2018/08/14/Vue%E6%8F%92%E6%A7%BD%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
      <content type="html"><![CDATA[<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>  利用插槽,父组件可以向子组件里面注入内容.<br>  注：插槽的视图部分的样式由父组件决定,子组件决定数据.也就是说是子组件给父组件传递数据.<br>  插槽的类型有：</p><ul><li><p>单个插槽的使用<br>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是插槽<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">//这里会显示“我是插槽”</span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>具名插槽的使用<br>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"s1"</span>&gt;</span>我是插槽1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"s1"</span>&gt;</span></span><br><span class="line">//这里会显示“我是插槽1”</span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>作用域插槽的使用(数据传递)<br>子组件传递</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"s2"</span> <span class="attr">text</span>=<span class="string">"我是数据传递"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">//此处传递的是text</span><br></pre></td></tr></table></figure><p>父组件展示子组件传来的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span> <span class="attr">slot</span>=<span class="string">"s2"</span>&gt;</span></span><br><span class="line">       &#123;&#123; props.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//此处props可以为其他名字，它只是一个key值</span><br></pre></td></tr></table></figure></li></ul><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="缓存-keep-alive"><a href="#缓存-keep-alive" class="headerlink" title="缓存(keep alive)"></a>缓存(keep alive)</h3><ul><li><p>用法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>什么时候情况下使用缓存？   </p><p>如果需要实时更新,则不设置缓存,否则可以使用缓存.</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue子组件如何向父组件通信？</title>
      <link href="/2018/08/14/%E5%AD%90%E7%BB%84%E4%BB%B6%E5%92%8C%E7%88%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
      <content type="html"><![CDATA[<h3 id="Vue子组件向父组件传递信息"><a href="#Vue子组件向父组件传递信息" class="headerlink" title="Vue子组件向父组件传递信息"></a>Vue子组件向父组件传递信息</h3><p>  1.子组件通过自定义事件(emit Event)向父组件传递信息<br>  2.传递步骤及方法</p><ul><li><p>先在子组件中自定义一个方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"sendMsg"</span>&gt;</span>发送数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">//自定义了一个sendMsg的方法</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>在methods中注册该方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> methods:&#123;</span><br><span class="line"> sendMsg(event)&#123;</span><br><span class="line">   //两个参数,参数1:key  参数2: 数据</span><br><span class="line">   this.$emit(&quot;sendmsg&quot;,this.msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意传递时应为两个参数：参数1 : key  参数2 : 数据</p></li><li><p>在父组件中为key值定义绑定事件获取传递值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">sendmsg</span>=<span class="string">"getMsg"</span>/&gt;</span></span><br><span class="line">//此处的key为sendmsg,为其定义了一个getMsg事件</span><br></pre></td></tr></table></figure></li><li><p>在父组件methods注册该方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  methods:&#123;</span><br><span class="line">  getMsg(data)&#123;</span><br><span class="line">    this.info = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//  此时的data的值即为子组件传递的数据,在这里将它赋值给info</span><br></pre></td></tr></table></figure></li></ul><h3 id="子父级组件信息传递的总结"><a href="#子父级组件信息传递的总结" class="headerlink" title="子父级组件信息传递的总结"></a>子父级组件信息传递的总结</h3><p>  往往子父级组件传递数据的用法是父组件向子组件传递了数据,在子组件中处理了数据之后,又将数据返回给父组件进行其他的处理.所以往往子父级组件传递数据是相互存在的.</p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue组件</title>
      <link href="/2018/08/12/Vue%E7%BB%84%E4%BB%B6/"/>
      <content type="html"><![CDATA[<h3 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h3><p>  组件是Vue.js最核心的功能之一,组件可以扩展HTML元素,封装可重用的代码.<br>  所以的组件都是Vue的一个实例.<br>  一个单组件分为三部分：</p><ul><li>template(HTML部分)</li><li>script(逻辑部分)</li><li><p>style(样式部分)   </p><a id="more"></a><p>注意：<br>1.template里面只能有一个根组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    我是根组件</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>2.style的scoped属性：样式只在当前组件内生效</p></li></ul><h3 id="子父级组件"><a href="#子父级组件" class="headerlink" title="子父级组件"></a>子父级组件</h3><p>  顾名思义,一个组件包含了另一个组件,就形成了子父级组件的关系.<br>  1.在父组件导入子组件的方法：</p><ul><li><p>先为子组件起名并导入文件位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Son from &quot;子组件文件位置&quot;</span><br></pre></td></tr></table></figure></li><li><p>创建components将子组件注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Son</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.子父级组件之间的交互：<br>父组件要给子组件下发数据,子组件要告诉父组件发生了什么事情,所以需要通信.他们之间的通信总结为props向下传递,事件(Event)向上传递.即是父组件通过props给子组件下发数据,子组件通过事件给父组件发送消息.</p></li><li><p>父组件给子组件下发数据：<br>1.父组件发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Son v-bind:title=&quot;msg&quot;/&gt;</span><br></pre></td></tr></table></figure><p>2.子组件引用(在data同级目录下声明props)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props:[&quot;title&quot;]</span><br></pre></td></tr></table></figure></li></ul><h3 id="props数据传递检测"><a href="#props数据传递检测" class="headerlink" title="props数据传递检测"></a>props数据传递检测</h3><ul><li><p>检测传入值数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">  title:String,(即是说传入的title应该为String类型)</span><br><span class="line">  num:Number,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当然传入值可以是多种数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">  title:[String,Number],(即是说传入的title可以为String类型或者Number类型)</span><br><span class="line">  num:Number,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定传入值必选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">  title:&#123;</span><br><span class="line">    type:String,</span><br><span class="line">    required:true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定传入值默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">  num:&#123;</span><br><span class="line">    type:Number,</span><br><span class="line">    default:5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传入值可以为一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">  myobj:&#123;</span><br><span class="line">    type:Object,</span><br><span class="line">    default:function()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name:&quot;未知&quot;,</span><br><span class="line">        age:10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>回到Hexo</title>
      <link href="/2018/08/11/%E5%9B%9E%E5%88%B0Hexo/"/>
      <content type="html"><![CDATA[<h3 id="重新回到Hexo"><a href="#重新回到Hexo" class="headerlink" title="重新回到Hexo"></a>重新回到Hexo</h3><p>  兜兜转转，还是回到了<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>+<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>的怀抱.<br>  别问我为什么,因为很专业（免费）😏！</p><h3 id="技术博客的重要性"><a href="#技术博客的重要性" class="headerlink" title="技术博客的重要性"></a>技术博客的重要性</h3><p>  因为近来经常面试的原因,发现外面的公司大都会优先考虑有技术博客或者GitHub的学生.<br>  例如<br>  <img src="http://wx1.sinaimg.cn/large/89296167gy1fu5ngjns3lj21kw0pewk7.jpg" alt="Github需求" title="GitHub需求"><br>  <a id="more"></a><br>  <br><br>  所以真的很有必要好好构建一下自己的技术博客和GitHub.技术博客不仅能展示出自己的技能水平,而且能对自己的学习进行总结.这对于要一直学习的程序员来说,是很有必要的.作为一名程序员，如果没有GitHub的话，那就真的落后了.可以将自己的项目和Demo托管到GitHub,供自己备份和别人共享使用.同时也可以参与别人的开源项目,如果有幸能参与到大型项目里面,这将变成你竞争中最有力的一笔.所以赶紧将自己的技术博客和github搭建起来吧！</p><h3 id="面试经验总结"><a href="#面试经验总结" class="headerlink" title="面试经验总结"></a>面试经验总结</h3><p>   从七月份学校结课了以来,我就开始在网上疯狂投递简历，然后就开始了疯狂面试.刚开始先是在重庆.<br>   面试的公司有：   </p><ul><li><a href="http://www.11467.com/qiye/61757036.htm" target="_blank" rel="noopener">义方人科技</a></li><li><a href="https://www2.deloitte.com/cn/zh.html" target="_blank" rel="noopener">德勤.中国</a>  </li></ul><p>  然后来到了无锡、苏州、上海,面试的公司有:</p><ul><li><a href="http://www.iflytek.com/" target="_blank" rel="noopener">科大讯飞</a></li><li><a href="http://www.sanjia-soft.com/" target="_blank" rel="noopener">三家软件</a></li><li><a href="http://www.wxleshitong.com/" target="_blank" rel="noopener">乐识通</a></li><li><a href="https://www.wifi.com/" target="_blank" rel="noopener">WIFI-万能钥匙</a>     </li></ul><p>  到2018年-8-13为止,前前后后面试了这么多家公司.我面试的岗位是web前端工程师,当然是实习岗位.通过这么多次到面试,我收获了很多,了解到自己与行业内真正的技术要求的差距.就前端而言,除了要掌握最基础的HTML、CSS、JS之外,还必须要掌握很多<a href="https://baike.baidu.com/item/MVVM/96310" target="_blank" rel="noopener">MVVM</a>模型框架.例如<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue</a>、<a href="http://react-china.org/" target="_blank" rel="noopener">React</a>.当然学习和掌握这些框架都建立在你对<a href="http://www.w3school.com.cn/js/" target="_blank" rel="noopener">JS</a>十分精通的情况下. 现在前端的开发越来越趋于组件化、模块化,前端的许多框架已经能胜任部分后端的任务.还有一些很多新的技能要求,例如:<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>、<a href="http://webpack.github.io/" target="_blank" rel="noopener">webpack</a>等等.不仅如此,现在前端的开发越来越趋于跨平台,往往一套完整的页面能在不同分辨率的屏幕上使用.由于这些种种新的要求,对开发人员的要求也越来越高,就web前端工程师来说,必须深入了解网络各个协议及其运作原理,对网络安全的要求也越来越高.总的来说,前端工程师再也不是仅仅是开发页面那么简单,必须掌握很多专业知识，才能胜任现在的开发工作.</p><h3 id="未来（近期）的计划"><a href="#未来（近期）的计划" class="headerlink" title="未来（近期）的计划"></a>未来（近期）的计划</h3><p> 我现在还在上海这边,短期内的计划是边找工作边学习.目前在学习vue,计划是在八月份把vue学完,然后做一个练手项目.另外对<a href="https://electronjs.org/" target="_blank" rel="noopener">electron</a>很感兴趣,也准备去研究研究在接下来的学习中,我会不定期地更新自己的技术博客,以达到总结提升的作用.<br> 共勉,以上✌️</p>]]></content>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
