<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  Docker基本知识 |   写夜子的个人博客 </title>

 
  
    <link rel="icon" href="/images/favicon.png">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-nav">        
   
    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-menu">          
              
            
              <a class="header-menu-link" id="header-menu-home" href="/">首页</a>     
            
            
            
              <a class="header-menu-link" id="header-menu-archives" href="/archives">归档</a>     
            
            
            
              <a class="header-menu-link" id="header-menu-tags" href="/tags">标签</a>     
            
            
            
              <a class="header-menu-link" id="header-menu-about" href="/about">关于</a>     
            
            
            
              <a class="iconfont icon-menu-search header-menu-link" id="header-menu-search"></a>
            
                
    </div>  
    
  </nav>
</header>   

      <div class="container">       
          
          
            <section class="main">  
          

          <article class="post">
  
	<div class="post-header">

	<p class="post-title">	
		docker基本知识
	</p>
			

	<div class="meta-info">	
	<span>
		8月 23, 2019
	</span>

	
	
		<i class="iconfont icon-words"></i>
		<span>
			3543
		</span>
	
</div>

</div> 
	 

	  <div class="post-content slideDownMin">

		

			
					<h1 id="docker学习笔记"><a href="#docker学习笔记" class="headerlink" title="docker学习笔记"></a>docker学习笔记</h1><p>  以下为docker的学习笔记。</p>
<h3 id="镜像-image-文件"><a href="#镜像-image-文件" class="headerlink" title="镜像(image)文件"></a>镜像(image)文件</h3><ol>
<li>docker把应用程序及其依赖，打包在image文件里面</li>
<li>image文件可以看做是容器的模板，docker根据image文件生成容器的实例</li>
<li>同一个image文件，可以生成多个同时运行的模板</li>
<li><code>docker image pull</code> 是抓取image文件的命令 (eg: <code>docker image pull hello-world</code>)</li>
<li>使用<code>docker image ls</code>查看本机下面的已有的docker image文件</li>
<li>运行image文件:<code>docker container run hello-world</code>,该命令会从image文件，生成一个正在运行的容器实例</li>
<li>终止正在运行的容器: <code>docker container kill [containID]</code><a id="more"></a>
</li>
</ol>
<h3 id="容器-container-文件"><a href="#容器-container-文件" class="headerlink" title="容器(container)文件"></a>容器(container)文件</h3><ol>
<li>容器文件指的是image文件生成的容器实例</li>
<li>关闭容器不会删除容器，只会停止运行</li>
<li>查看本机正在运行的容器: <code>docker container ls</code></li>
<li>查看本机所有的容器(运行和非运行): <code>docker container ls --all</code></li>
<li>删除容器: <code>docker container rm [containerID]</code></li>
</ol>
<h3 id="Dcokerfile文件"><a href="#Dcokerfile文件" class="headerlink" title="Dcokerfile文件"></a>Dcokerfile文件</h3><p>  用来配置image 的文本文件。 Docker会根据该文件生成二进制的image文件。<br>  写Dockerfile文件的步骤:</p>
<ol>
<li>先clone自己的项目: <code>git clone xxxx</code>;</li>
<li><p>在项目的根目录下，新建一个文本文件:<code>.dockerignore</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line"> node_modules</span><br><span class="line"> npm-debug.log</span><br></pre></td></tr></table></figure>
<p>该文件会排除以上的三个路径下的文件，告诉docker不要将这三个打包到image文件。</p>
</li>
</ol>
<ol start="3">
<li>在项目的根目录下，新建一个文本文件<code>Dockerfile</code>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4       //指定node的版本</span><br><span class="line">COPY . /app        //将当前目录下的所有文件，都拷贝至iamge文件的/app目录</span><br><span class="line">WORKDIR /app       // 指定接下来的工作路径为/app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org  // 在/app目录下，运行npm intall 安装项目依赖，这些依赖都会被打包进image文件</span><br><span class="line">EXPOSE 3000        //将容器的3000端口暴露出来，允许外部连接</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="创建image文件"><a href="#创建image文件" class="headerlink" title="创建image文件"></a>创建image文件</h3><p>  有了Dockerfile文件之后，就可以使用 <code>docker iamge build</code> 命令来创建image文件了。<br>  创建命令:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t [imageName] .</span><br></pre></td></tr></table></figure></p>
<p>  或者:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t [imageName]:0.0.1 .</span><br></pre></td></tr></table></figure></p>
<p>  <code>-t</code> 指定文件image文件的名字， 最后那个点则是Dockerfile文件所在的路径，还可以使用<code>:</code>来指定标签<br>  执行完成之后，查看当前image文件: <code>docker image ls</code></p>
<h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p>   <code>docker container run</code> 命令会从image文件生成容器:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8000:3000 -it [iamgeName] /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>   或者:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8000:3000 -it [iamgeName]:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>   或者:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3000:80 -d --name [containerName] [iamgeName]</span><br></pre></td></tr></table></figure></p>
<p>   <code>-p</code>参数: 容器的3000端口映射到本机的8000端口   </p>
<p>   <code>-it</code>参数: 容器的Shell映射到当前的Shell，然后你在本机窗口输入的命令，就会传入到容器 </p>
<p>   <code>-d</code>参数: 让容器在后台运行</p>
<p>   <code>--name</code>参数: 指定容器名称</p>
<p>   <code>/bin/bash</code>参数: 容器启动以后，内部第一个执行的命令，这里是启动Bash，保证用户可以使用Shell<br>   当跑完这些命令的时候，会返回一个命令行提示符，然后就可以在里面执行命令了</p>
<h3 id="其他有用的命令"><a href="#其他有用的命令" class="headerlink" title="其他有用的命令"></a>其他有用的命令</h3><p>  （1）<code>docker container start</code><br>    前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container start [containerID]</span><br></pre></td></tr></table></figure></p>
<p>（2）<code>docker container stop</code><br>   前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash container stop [containerID]</span><br></pre></td></tr></table></figure></p>
<p>   这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>
<p>（3）<code>docker container logs</code></p>
<p>   <code>docker container logs</code> 命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [containerID]</span><br></pre></td></tr></table></figure></p>
<p>（4）<code>docker container exec</code></p>
<p> <code>docker container exec</code>  命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container exec -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure>
<p>（5）<code>docker container cp</code></p>
<p>  <code>docker container cp</code> 命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp [containID]:[/path/to/file]</span><br></pre></td></tr></table></figure>
<h3 id="Docker-Compose工具"><a href="#Docker-Compose工具" class="headerlink" title="Docker Compose工具"></a>Docker Compose工具</h3><p>  Compose可以管理多个Docker容器组成一个应用。定义一个 <code>.yaml</code>的配置文件 <code>docker-compose.yml</code>,在这个文件里面写好多个容器之间的调用关系。然后只要一个命令，即可同时启动/关闭这些容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up   //启动所有服务</span><br><span class="line">docker-compose stop //关闭所有服务</span><br><span class="line">docker-compose rm   // 删除所有容器</span><br></pre></td></tr></table></figure></p>
<h3 id="docker更改镜像加速器"><a href="#docker更改镜像加速器" class="headerlink" title="docker更改镜像加速器"></a>docker更改镜像加速器</h3><p>  进入 <code>/etc/docker/daemon.json</code> 里面编辑(没有这个文件请新建):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://dockerhub.azk8s.cn&quot;,</span><br><span class="line">    &quot;https://reg-mirror.qiniu.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   然后重启docker即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>然后执行 <code>docker info</code> 查看配置是否生效</p>
<h3 id="需要继续深入学习的东西"><a href="#需要继续深入学习的东西" class="headerlink" title="需要继续深入学习的东西"></a>需要继续深入学习的东西</h3><ol>
<li>Dockerfile文件的编写</li>
<li>docker-compose.yaml的编写</li>
</ol>
<h3 id="现在的问题"><a href="#现在的问题" class="headerlink" title="现在的问题"></a>现在的问题</h3><ol>
<li><p>是不是写了Dockerfile文件之后，在服务器直接拉取代码，然后根据Dcokerfile制作项目image，如果是vue项目，是否就不用打包了？因为只需根据Dockerfile制作的image启动容器即可。</p>
<p>我的看法：应当还是要打包的，但是打包操作是在Dockerfile文件里面执行吗？或者还有一种思路，就是先在本地打包，并把Dcokerfile也打包进dist目录，在服务器上拉取代码，然后进入dist目录，再根据Dockerfile文件制作image？</p>
</li>
<li><p>如何利用 <code>docker-compose</code> 将vue前台服务和后台服务写到同一个image里面？(前台和后台是分开的，前台的请求会反向代理到后台，后台为一个Node.js服务，不涉及到数据库。等于说，前台服务需要nginx，后台则需要node)</p>
</li>
</ol>
<ol start="3">
<li><p>如何实现以下的docker编排？</p>
<p><img src="https://i.loli.net/2019/08/20/ZTr3s1CbV7vG9Bq.png" alt="docker服务编排.png"></p>
</li>
</ol>
<h3 id="查看container的IP地址"><a href="#查看container的IP地址" class="headerlink" title="查看container的IP地址"></a>查看container的IP地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exect -it [containerName] bash</span><br><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure>
<p>   或者直接使用 <code>docker inspect [containerName]</code> 查看IP地址</p>
  	
					
	  </div>     
	  

	
<div class="post-meta">
      	

      
        <i class="iconfont icon-tag"></i>     
          <a class="tag-link" href="/tags/docker/">docker</a> <a class="tag-link" href="/tags/nginx/">nginx</a>    
      	
</div>





<div class="post-footer">
  <div class="pf-left">
      <img class="pf-avatar" src="https://i.loli.net/2019/04/25/5cc1786ceef93.png">
      <p class="pf-des">hi,我是写夜子,希望你有愉快的一天.</p>
  </div>

  <div class="pf-right">           
      <div class="pf-links">
        




<span class="donate-btn">
	<span class="iconfont icon-donate"></span>
</span>


<div id="donate-box" class="sildeUpMin">

	<span class="donate-cancel iconfont icon-cancel"></span>

	<div class="donate-img-box">
		<img id="donate-qr-wechat" class="noLazyLoad donate-img" src="/images/donate1.png" alt="No Donate Image!">	
		<img id="donate-qr-alipay" class="noLazyLoad donate-img" src="/images/donate2.png" alt="No Donate Image!">	
	</div>

	<span class="donate-word">世界美好 你也是</span>

	<div class="donate-list">
		<span class="iconfont icon-donate-wechat"></span>
		<span class="iconfont icon-donate-alipay"></span>
	</div>

</div>

 
        
	
<script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=21d601593a1de"></script>
	
	<span class="share-btn">
	<span class="iconfont icon-share"></span>
	</span>


	<div class="-mob-share sildeUpMin">
		   			             
            <a class="iconfont  icon-share-qq -mob-share-qq"></a>		
     	   			             
            <a class="iconfont  icon-share-weixin -mob-share-weixin"></a>		
     	   			             
            <a class="iconfont  icon-share-weibo -mob-share-weibo"></a>		
     	   			             
            <a class="iconfont  icon-share-douban -mob-share-douban"></a>		
     	   			             
            <a class="iconfont  icon-share-facebook -mob-share-facebook"></a>		
     	   			             
            <a class="iconfont  icon-share-twitter -mob-share-twitter"></a>		
     	   			             
            <a class="iconfont  icon-share-google -mob-share-google"></a>		
     	   
	</div>	

      </div>  
    <nav class="pf-paginator">
      
         
          <a href="/2019/08/23/Dockerfile文件编写/" data-hover="Dockerfile文件编写">上一篇</a>      
            
        
      
        
        <a href="/2019/08/13/import 和 require 的区别/" data-hover="import 和 require 的区别"> 下一篇</a>
            
  </nav>   
  </div>
</div> 
	


    <div id="comment">   
    </div>

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>

    <script src="//unpkg.com/valine@v1.1.8-beta/dist/Valine.min.js"></script>

    <script>
        new Valine({
        el: '#comment',
        notify:false, 
        verify:false, 
        app_id: 'cFM0eCo0CQ9xmBXmHi1eltol-gzGzoHsz',
        app_key: 'oh9tizsnvV2vNvWgqEvoNtQO',  
        path:window.location.pathname, 
        avatar:'mm' ,
        guest_info:['nick','mail']
        });
    </script>
	
</article>

          </section> 
      </div>            
    
    <a id="backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">  
            <span class="search-cancel iconfont icon-cancel"></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/favicon.png">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?636802045446222199ae541e32c8133e"; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>





     
    




<footer id="footer">


		<div class="footer-copyright">
		&copy;
		
		2018-
		
		2019

		Xieyezi
		<br>

		Copyright
		<a href="http://www.xieyezi.com/" target="_blank">Xieyezi</a>
		</div>

</footer>
   

  

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>